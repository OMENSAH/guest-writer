---
layout: post
title: "Developing Modern Apps with React Material-IU"
description: "React components that implement Google's Material Design"
date: "2019-04-27 08:30"
author:
  name: "Oliver Mensah"
  url: "OliverMensahDev"
  mail: "olivermensah96@gmail.com"
  avatar: "https://twitter.com/OliverMensahDev/profile_image?size=original"
related:
- 2017-11-15-an-example-of-all-possible-elements
---

**TL:DR:** In this article, you will learn about the basic concepts of React Material-UI while developing a simple application.

## Prerequisites

In order for you to follow through how to setup Material-UI library in any React applications, it is recommended to have a prior experience working with [React](https://reactjs.org/).

To get started with the tutorial you will need Node.js and NPM installed on your development environment. If you don't, kindly [follow these instructions on the official documentation to install Node.js](https://nodejs.org/en/download/). Having Node.js installed means you have NPM as well since NPM comes with Node.js. 

Finally, you need to get access to your terminal or command prompt since React applications are preferably developed with the help of command line interface utility.

## What You Will Build

You will be building a sample application that utilizes most of the concept you will be learning from the walk-through of Material-UI. This sample project allows users authenticated with Auth0 to create events as well as view their Auth0 profile details. The created events are then displayed in a tabular view in a dashboard page. 

## React Material-UI Introduction

React Material-UI is the world's most popular React UI framework according to [the official website](https://material-ui.com/). Basically, it is made of React components that implement Google's Material Design specifications. React Material UI provides prebuilt UI components, icons and themes to build a good looking application.


## Setting up Material-UI with React.

Adding Material-UI to React application starts by adding the Material UI library as a dependency your React project. Create your project by the help of [create-react-app](https://facebook.github.io/create-react-app/), a tool that is developed and maintained by Facebook team for creating pre-configured React project. If you don't have Create-React-App package installed in your development environment, install it as follows;

```bash
npm i -g  create-react-app
```

**NB::** If you get permission issues then run this command us an admin or root user. 

Once, you have installed it, use the `create-react-app` command to create your React project by issuing the command below; Where **projectName**  is the name of your project.

```bash
create-react-app projectName 
```

### Cleaning App The Generated Boilerplate.

Creating a project with Create-React-App generates a pre-configured React project with certain files and folders. Depending on your project scope, some of the files will not be needed hence you can get rid of them. Files like `App.test.js`, `logo.svg`, `serviceworkers.js` in `./src`  folder should be removed. Also, remove the content of `App.css`, `index.css` and update `index.js` to have the content below.

```js
import React from 'react';
import ReactDOM from 'react-dom';
import './index.css';
import App from './App';

ReactDOM.render(<App />, document.getElementById('root'));
```

Also, update the `./src/App.js` to the content below;

```js
import React from 'react';
import './App.css';

function App() {
  return (
    <div>
    </div>
  );
}

export default App;
```

To make sure the app works without any error, you can test in your browser by running the project using `npm start` command at the project's root directory in your terminal.  This will serve the project will be on a development server via http://localhost:3000/. Make sure there is no error showing in the browser's console. 

### Installing and Working with Material-UI

Adding Material-UI library to React project is the same as adding other libraries to React project.  Go ahead to add Material-UI to your project with the command below.

```bash
npm install @material-ui/core 
```

By testing a few components from Material-UI,  update `./src/App.js` content as follows;

```js
import React from 'react';
import './App.css';
import Button from '@material-ui/core/Button';

function App() {
  return (
    <div>
      <Button variant="contained" color="primary">Test</Button>
    </div>
  );
}

export default App;
```

Here, you just added Button component from the Material-UI library. You might notice that the Button component includes props like:
  1. variant: provides the visual style of the component. This can be either contained, outlined, fab.
  2. color: gives that button background color. It can be either primary, secondary, or default.

There are a lot of properties you can add to such components. The best way to get to know more of these properties is to explore them by visiting the Material-UI Component APIs documentation.  For instance, the Button Component API has its documentation available at [https://material-ui.com/api/button/](https://material-ui.com/api/button/).
**NB::** Do well to visit the documentation to learn more about the properties of these components.


### Installing and Working with Icons

React Material-UI provides pre-built icons that you can use in your project but they don't come with the Material-UI package on installation. You need to install them separately. To install, use the command below;

```bash
npm install @material-ui/icons
```
Testing to see how to use these icons, update the `./src/App.js` file as follows;

```js
import React from 'react';
import './App.css';
import Button from '@material-ui/core/Button';
import Info from "@material-ui/icons/Info";

function App() {
  return (
    <div>
      <Button variant="contained" color="secondary">
        <Info/> Test
      </Button>
    </div>
  );
}
export default App
```

Here, you just imported Info icon to the project. And then used it before the Button's component text.

**NB** To use a specific icon, you can visit [MATERIAL DESIGN ICONS](https://material.io/tools/icons) to find an icon and then you import it by Pascal-casing its name.


## Implementing the Sample Project

Now that you have learned how to use Material-UI components and icons, you can start implementing the sample project to use more of these components and icons. The sample project makes use of Material-UI components to display the tabular list of events' data as well create a form to create an event. It also consists of the navigation bar which contains navigation drawer, dropdown list as well as navigation links. 

In terms of structure, the project will have `components` folder to hold components that can be used in different components. It will also contain the `pages` folder to hold all components that would be used as pages. And a `service` folder to hold third-party services like Auth0 that would be used in the application. Finally, `./src/App.js` will be the root component to load other components and pages of the entire application. 

To begin with, you will need to clean up the `App.js` to:

```js

import React, { Component } from "react";
import "./App.css";

class App extends Component {
  render() {
    return (
      <div>

      </div>
    );
  }
}
export default App;

```

### Developing the Navigation component 

The project's navigation bar can be implemented using AppBar component from the Material-UI library.  To do so, create a `components` sub-folder in `src` directory. In the `components` folder, create `./NavBar/NavBar.js` file and add the code below to the newly created file.

```js
import React from 'react'
import AppBar from '@material-ui/core/AppBar'
import Toolbar from '@material-ui/core/Toolbar'
import Typography from '@material-ui/core/Typography'
const NavBar = () => {
    return(
        <div>
        <AppBar position="fixed">
            <Toolbar>
                <Typography variant="title" color="inherit">
                  Home
                </Typography>
            </Toolbar>
        </AppBar>
        </div>
    )
}
export default NavBar;
```

Here, you are making use of AppBar, Toolbar and Typography components from the Material-UI library to create the navigation bar. The component is then exported.


The sample project will have a common navigation bar hence you need to import and use `NavBar` class component at the root component, `./src/App.js` as follows;

```js
import React, { Component } from "react";
import "./App.css";

import NavBar from "./components/NavBar/NavBar";


class App extends Component {
  render() {
    return (
      <div>
        <NavBar/>
      </div>
    );
  }
}
export default App;
```

Running the project again, you will see the navigation bar displayed in the browser.  There are other components like a drawer that you can add to this Navigation bar. The drawer will consist of list items and some icons. To implement a drawer, import these extra dependencies that will be needed to create a basic drawer in the NavBar component.

```js
import Drawer from "@material-ui/core/Drawer";
import ChevronLeftIcon from "@material-ui/icons/ChevronLeft";
import ListItem from "@material-ui/core/ListItem";
import ListItemIcon from "@material-ui/core/ListItemIcon";
import ListItemText from "@material-ui/core/ListItemText";
import Add from "@material-ui/icons/Add";
import Info from "@material-ui/icons/Info";
import Divider from "@material-ui/core/Divider";
import List from "@material-ui/core/List";
import IconButton from "@material-ui/core/IconButton";
import MenuIcon from "@material-ui/icons/Menu";
```

With the drawer, you have to change the NavBar from functional component to class component so as to manage some states of the drawer. Usually, a drawer needs to be toggled hence you got to manage its state when it is either opened or closed.

```js
class NavBar extends React.Component {
  
  render() {
    return (
      <div>
        <AppBar position="fixed">
          <Toolbar>
            <IconButton
              color="inherit"
              aria-label="Open drawer"
            >
              <MenuIcon />
            </IconButton>

            <Typography variant="title" color="inherit">
              Home
            </Typography>
          </Toolbar>
        </AppBar>
        <Drawer variant="persistent"  anchor="left" open={true}>
          <div>
            <IconButton >
              <ChevronLeftIcon />
            </IconButton>
          </div>
          <Divider />
          <List>
            <ListItem button>
              <ListItemIcon>
                <Info />
              </ListItemIcon>
              <ListItemText primary="About" />
            </ListItem>

            <ListItem button>
              <ListItemIcon>
                <Add />
              </ListItemIcon>
              <ListItemText primary="Add Event" />
            </ListItem>
          </List>
        </Drawer>
      </div>
    );
  }
}
export default NavBar;
```

The drawer you just added has two items and it is always opened. It should not be so.  It only opens when the MenuIcon is used to click. Adding up that functionality of opening or closing a drawer to your NavBar component, then you should update `NavBar.js` file to the code below.

```js
class NavBar extends React.Component {

  constructor(props){
    super(props);
    this.state = {
      openDrawer: false
    }
  }

  handleDrawerOpen = () => {
    this.setState({ openDrawer: true });
  };

  handleDrawerClose = () => {
    this.setState({ openDrawer: false });
  };
  
  render() {
    return (
      <div>
        <AppBar position="fixed">
          <Toolbar>
            <IconButton
            color="inherit"
            aria-label="Open drawer"
            onClick={this.handleDrawerOpen}
            >
             <MenuIcon />
            </IconButton>
           {/* ...Home Typography Here */}
          </Toolbar>
        </AppBar>
        <Drawer 
          variant="persistent" 
          anchor="left" 
          open={this.state.openDrawer}>
          <div>
            <IconButton
              onClick={this.handleDrawerClose}>
              <ChevronLeftIcon />
            </IconButton>
          </div>
            {/* ...Divider Here */}
            {/* ...List of Menu Items Here */}
          </Drawer>
      </div>
    );
  }
}
export default NavBar;
```

**NB**: For brevity, you have some section of the code replaced with comments. Which means those sections have not changed so you got to maintain them. 

Here,  you added a few properties like openDrawer. Currently, it is set to false. This state property will keep track of whether the drawer is opened or closed. The openDrawer state property is then manipulated by two methods; `handleDrawerOpen` and `handleDrawerClose` where it is reset to true and false respectively. When the MenuIcon is clicked, `handleDrawerOpen` method is invoked and thus changing the state of the drawer to true.  The drawer has ChevronLeftIcon (<)  which when clicked closes the drawer by also referencing `handleDrawerClose` method.  

You might have noticed already that when the MenuIcon is clicked to open the drawer, the drawer covers the MenuIcon and the text on the navigation. The navigation bar should be shifted to the right when the MenuIcon is clicked and when it is closed, it should get back to its original position. This is achieved by just adding some few CSS styles to the AppBar using [CSS-in-JS](https://material-ui.com/customization/css-in-js/) approach. This approach uses higher-order component, `withStyles`, to inject an array of styles into the DOM as CSS using JS.

Before NavBar class, add the code below:

```js
//... some imports

const drawerWidth = 240;
const styles = theme => ({
  appBar: {
    transition: theme.transitions.create(["margin", "width"], {
      easing: theme.transitions.easing.sharp,
      duration: theme.transitions.duration.leavingScreen
    })
  },
  appBarShift: {
    width: `calc(100% - ${drawerWidth}px)`,
    marginLeft: drawerWidth,
    transition: theme.transitions.create(["margin", "width"], {
      easing: theme.transitions.easing.easeOut,
      duration: theme.transitions.duration.enteringScreen
    })
  }
});

class NavBar extends React.Component{
  // some class methods and properties
}
```

Now that you have the CSS classes, you need to import two components; classNames and withStyles. The className will also help in adding multiple classes to a component while withStyles will help in making these classes available in that component.

```js
import classNames from "classnames";
import { withStyles } from "@material-ui/core/styles";
```

To inject that styles you created to have an effect on the component you have to export `NavBar` as module wrapped with a `withStyles` higher order component as shown below;

```js
export default withStyles(styles)(NavBar);
```

Wrapping the class with `withStyles` passes down classes property to reference the CSS styles in that component. To access this classes in the component, go ahead to access it in the `render` method of the component by destructuring the component's properties as shown below;

```js
  const { classes } = this.props;
```

Finally, apply the following code as property to the AppBar;

```js
className = { classNames(classes.appBar, {[classes.appBarShift]: this.state.openDrawer})}
```

On viewing the application in the browser, you could see that the navigation looks better after clicking the MenuIcon. But there is so much space between the Drawer and the AppBar after each click. This can be solved by adding a few CSS styles.  In the CSS you created, add the following pieces of code;

```js
const styles = theme => ({
  //..other styles
  menuButton: {
    marginLeft: 20,
    marginRight: 20
  },
  drawer: {
    width: drawerWidth,
    flexShrink: 0
  },
  drawerPaper: {
    width: drawerWidth
  },
  drawerHeader: {
    display: "flex",
    alignItems: "center",
    padding: "0 8px",
    ...theme.mixins.toolbar,
    justifyContent: "flex-end"
  }
})
```

From the above CSS styles, menuButton will help create a margin between the menuIcon and the text. drawer provides the width of the drawer while drawerPaper and drawerHeader remove the margin between the drawer and the toolbar. Add these CSS styles to the few components like IconButton.

```js
<Toolbar>
  <IconButton
    {/* ...Other Props Here*/}
    className={classNames(
      classes.menuButton,
      this.state.openDrawer
    )}>
    <MenuIcon />
  </IconButton>
    {/* ...Other Components Here*/}
</Toolbar>  
```

Also, update the drawer and the div element to have the following CSS styles.

```js
<Drawer
  {/* ...Other Props Here*/}
  classes={{
    paper: classes.drawerPaper
  }}
  className={classes.drawer}>
  <div className={classes.drawerHeader}>
      {/* ...Other Components Here*/}
  </div>
</Drawer>
```

In all, your `NavBar` class component's code must be like this;

```js
import React from "react";
import AppBar from "@material-ui/core/AppBar";
import Toolbar from "@material-ui/core/Toolbar";
import Typography from "@material-ui/core/Typography";
import IconButton from "@material-ui/core/IconButton";
import MenuIcon from "@material-ui/icons/Menu";

import Drawer from "@material-ui/core/Drawer";
import ChevronLeftIcon from "@material-ui/icons/ChevronLeft";
import ListItem from "@material-ui/core/ListItem";
import ListItemIcon from "@material-ui/core/ListItemIcon";
import ListItemText from "@material-ui/core/ListItemText";
import Add from "@material-ui/icons/Add";
import Info from "@material-ui/icons/Info";
import Divider from "@material-ui/core/Divider";
import List from "@material-ui/core/List";

import classNames from "classnames";
import { withStyles } from "@material-ui/core/styles";

const drawerWidth = 240;
const styles = theme => ({
  appBar: {
    transition: theme.transitions.create(["margin", "width"], {
      easing: theme.transitions.easing.sharp,
      duration: theme.transitions.duration.leavingScreen
    })
  },
  appBarShift: {
    width: `calc(100% - ${drawerWidth}px)`,
    marginLeft: drawerWidth,
    transition: theme.transitions.create(["margin", "width"], {
      easing: theme.transitions.easing.easeOut,
      duration: theme.transitions.duration.enteringScreen
    })
  },
  menuButton: {
    marginLeft: 20,
    marginRight: 20
  },
  drawer: {
    width: drawerWidth,
    flexShrink: 0
  },
  drawerPaper: {
    width: drawerWidth
  },
  drawerHeader: {
    display: "flex",
    alignItems: "center",
    padding: "0 8px",
    ...theme.mixins.toolbar,
    justifyContent: "flex-end"
  }
});

class NavBar extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      openDrawer: false
    };
  }

  handleDrawerOpen = () => {
    this.setState({ openDrawer: true });
  };

  handleDrawerClose = () => {
    this.setState({ openDrawer: false });
  };

  render() {
    const { classes } = this.props;

    return (
      <div>
        <AppBar
          position="fixed"
          className={classNames(classes.appBar, {
            [classes.appBarShift]: this.state.openDrawer
          })}
        >
          <Toolbar>
            <IconButton
              color="inherit"
              aria-label="Open drawer"
              onClick={this.handleDrawerOpen}
              className={classNames(classes.menuButton, this.state.openDrawer)}
            >
              <MenuIcon />
            </IconButton>

            <Typography variant="title" color="inherit">
              Home
            </Typography>
          </Toolbar>
        </AppBar>
        <Drawer
          variant="persistent"
          anchor="left"
          open={this.state.openDrawer}
          classes={{
            paper: classes.drawerPaper
          }}
          className={classes.drawer}
        >
          <div className={classes.drawerHeader}>
            <IconButton onClick={this.handleDrawerClose}>
              <ChevronLeftIcon />
            </IconButton>
          </div>
          <Divider />
          <List>
            <ListItem button>
              <ListItemIcon>
                <Info />
              </ListItemIcon>
              <ListItemText primary="About" />
            </ListItem>

            <ListItem button>
              <ListItemIcon>
                <Add />
              </ListItemIcon>
              <ListItemText primary="Add Event" />
            </ListItem>
          </List>
        </Drawer>
      </div>
    );
  }
}
export default withStyles(styles)(NavBar);
```

The navigation bar implementation is by far great. However, the navigation bar needs to have links to other pages, hence you got to add navigation links. You will be using `react-router-dom`  package to handle the navigation since React does not come with routing implementation. Use the command below to do the installation.

```bash
  npm i react-router-dom
```

Then from `react-router-dom` package, import `NavLink` module into the `NavBar` component to create the link. 

```js
import { NavLink} from "react-router-dom";
```

You can convert the normal `Home` text on the navigation bar to a link by wrapping it with `NavLink` as bellow;

```js
<Typography variant="title" color="inherit">  
  <NavLink
    to="/"
    style={{ textDecoration: "none", color: "white" }}>
    Home
  </NavLink>
</Typography>
```

Here, few styles have been added to remove the underline and make the text white. After saving the file and testing in the browser, you will get some errors. This is basically telling us that the whole app is not set up to have routes. To solve this, you can wrap the whole application to use routes. Go to `./src/index.js` and update as follows;

```js
import React from "react";
import ReactDOM from "react-dom";
import "./index.css";
import App from "./App";
import { BrowserRouter, Route } from "react-router-dom";

ReactDOM.render(
  <BrowserRouter>
    <Route component={App} />
  </BrowserRouter>,
  document.getElementById("root")
);
```

Testing to see we have a link, a hover on the text turns the cursor to be clickable. Create another link item on the navigation bar after the Home text as;

```js
<Typography variant="h6" color="inherit">
  <NavLink
    to="/dashboard"
    style={{ textDecoration: "none", color: "white" }}>
    Dashboard
  </NavLink>
</Typography>
```

After adding Dashboard Link, there is no space between the two links. You can space them out by styling them with CSS. Update your styles to have these two additional properties;

```js
const styles = theme => ({
  //... Other Styles Here
  root: {
    display: "flex",
    flexGrow: 1
  },
  grow: {
    flexGrow: 1,
    marginLeft: 15
  }
})  
```

Using these styles will require you to update the parent div of the component and then the second navigation link item to have the styles you just added;

```js
class NavBar extends React.Component {
  //.. Other Component Methods Here
  render(){
    return(
      <div className={classes.root}>
        {/*... Other Components Here*/}
        <Typography 
          variant="h6" 
          color="inherit" 
          className={classes.grow}>
          <NavLink
            to="/dashboard"
            style={{ textDecoration: "none", color: "white" }}
          >
            Dashboard
          </NavLink>
        </Typography>
        {/*... Other Components Here*/}
      </div>
    )
  } 
}
```

Also, in our drawer, the About item has to be a link hence you need to update that as follows;

```js
<NavLink to="/about" style={{ textDecoration: "none" }}>
  <ListItem button>
    <ListItemIcon>
      <Info />
    </ListItemIcon>
    <ListItemText primary="About" />
  </ListItem>
</NavLink>
```

The navigation bar has to also contain a dropdown menu with two items, My Account and Logout. Implement this feature by importing some components and icons from the Material-UI and the icons libraries as follows;

```js
import AccountCircle from "@material-ui/icons/AccountCircle";
import MenuItem from "@material-ui/core/MenuItem";
import Menu from "@material-ui/core/Menu";
```

In the toolbar, right after the second navigation link, Dashboard, implement the dropdown menu as follows;

```js
<IconButton
  color="inherit">
  <AccountCircle />
</IconButton>
<Menu
  anchorOrigin={{
    vertical: "top",
    horizontal: "right"
  }}
  anchorEl={this.state.anchorEl}
  open={false}>
  <MenuItem>
    <NavLink
      to="/account"
      style={{ textDecoration: "none", color: "black" }}>
      My Account
      </NavLink>
  </MenuItem>
  <MenuItem>Logout</MenuItem>
</Menu>
```

Here, IconButton will be used to create popup menu elements. With the two elements, My Account link to Account page. 
Also, you are setting the open property of the Menu to false. Once it is true, the pop will show. This means we have to handle its state as well.

Update the state of the `NavBar` component to have anchorEl as state property with a value of null.  

**NB** anchorEl is the DOM elements that will be positioned in the popover. The boolean value can be determined this anchorEL. Thus if anchorEl has value that is not null, it means there are items to be displayed in the popover if not return null. Truthy values can then be determined to show or hide the popOver depending on the anchorEl returned value. 

Also, add these two methods to the `NavBar` component to manipulate the state of anchorEl

```js
 handleMenuOpen = event => {
    this.setState({ anchorEl: event.currentTarget });
  };

  handleMenuClose = () => {
    this.setState({ anchorEl: null });
  };
``` 

`handleMenuOpen` should be called when the IconButton is clicked and `handleMenuClose` executes when the menu closes. You can update both the Menu and IconButton components to reference these methods respectively as follows;

```js
 <IconButton
    {/*...Other Props Here*/}
    onClick={this.handleMenuOpen}
    >
    <AccountCircle />
  </IconButton>
  <Menu
    {/*...Other Props Here*/}
    open={showPopOver} {/* Changed from false to showPopOver */}
    onClose={this.handleMenuClose}>
```

The open property has updated to have a value of showPopOver instead of the false value.  This showPopOver is obtained from the truthy value of anchorEl. In the render method add the code below;

```js
const showPopOver = Boolean(this.state.anchorEl);
```

You have been able to achieve a navigation bar with almost its functionality achieve, later, you will hook in the remaining functionalities.


### Developing the Homepage component

The homepage has just a description of the application as well as a button for the user to login. Implement this by creating a new folder called `pages`. In that folder, create a subdirectory called `HomePage` which will hold `HomePage.js` file. In the newly created file, `HomePage.js`, you add these content;

```js
import React, { Component } from "react";
import Button from "@material-ui/core/Button";
import Typography from "@material-ui/core/Typography";

import "./HomePage.css";

class HomePage extends Component {
  render() {
    return (
      <div className="container">
        <div className="overlay"/>
        <div className="content">
          <h1>Event Scheme</h1>
          <Typography>
            Let's help you create and manage your events.
          </Typography>
          <Button
            variant="contained"
            color="primary"
            >
            Login
          </Button>
        </div>
      </div>
    );
  }
}
export default HomePage;
``` 

Here, you are using Button and Typography components from Material-UI. Also, there is an external CSS file, `HomePage.css` that is imported. Create such file in your current directory,`./src/pages/HomePage`  and add these CSS codes to it.

```css
.container {
  height: 100vh;
  display: flex;
  align-items: center;
  color: #fff;
  max-width: 960px;
  padding-left: 1rem;
  padding-right: 1rem;
  margin: auto;
  justify-content: center;
  text-align: center;
}

.overlay {
  height: 100vh;
  position: absolute;
  left: 0;
  width: 100vw;
  z-index: 1;
  background: #225470;
  opacity: 0.85;
}

.content {
  z-index: 3;
}

.content h1 {
  font-size: 50px;
  margin-bottom: 0;
}

.content p {
  font-size: 1.5rem;
  display: block;
  padding-bottom: 2rem;
}
```

### Developing the About component

Adding up the About component is similar to implementing the HomePage component. In your `pages` create another folder called `About`. In that `About` folder create `About.js` file.  With the About page, it uses Stepper component from Material UI to display content through a sequence of logical and numbered steps.  Add the following code this file;

```js
import React from "react";
import { withStyles } from "@material-ui/core/styles";
import Stepper from "@material-ui/core/Stepper";
import Step from "@material-ui/core/Step";
import StepLabel from "@material-ui/core/StepLabel";
import StepContent from "@material-ui/core/StepContent";
import Button from "@material-ui/core/Button";
import Paper from "@material-ui/core/Paper";
import Typography from "@material-ui/core/Typography";
import Grid from "@material-ui/core/Grid";

const styles = theme => ({
  root: {
    flexGrow: 1
  },
  button: {
    marginTop: theme.spacing.unit,
    marginRight: theme.spacing.unit
  },
  actionsContainer: {
    marginBottom: theme.spacing.unit * 2
  },
  resetContainer: {
    padding: theme.spacing.unit * 3
  }
});

function getSteps() {
  return ["About Us", "What We do?", "What Others are Saying?"];
}

function getStepContent(step) {
  switch (step) {
    case 0:
      return `Success Scheme is the world's largest event management technology platform,
       making sure millions of events happening across the globe are well managed. 
       We give event organizers the power to when it comes to event management`;
    case 1:
      return `At Success Scheme, we give power to event organizers when managing their events in just one place. 
      Easier to sync across multiple devices and discovered by millions of people on all social media platforms`;
    case 2:
      return `Try out different ad text to see what brings in the most customers,
              and learn how to enhance your ads using features like ad extensions.
              If you run into any problems with your ads, find out how to tell if
              they're running and how to resolve approval issues. -- John Doe`;
    default:
      return "Unknown step";
  }
}

class About extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      activeStep: 0
    };
  }

  handleNext = () => {
    this.setState(state => ({
      activeStep: state.activeStep + 1
    }));
  };

  handleBack = () => {
    this.setState(state => ({
      activeStep: state.activeStep - 1
    }));
  };

  handleReset = () => {
    this.setState({
      activeStep: 0
    });
  };

  render() {
    const { classes } = this.props;
    const steps = getSteps();
    const { activeStep } = this.state;

    return (
      <div className={classes.root}>
        <Grid container alignItems="center" justify="center">
          <Stepper activeStep={activeStep} orientation="vertical">
            {steps.map((label, index) => (
              <Step key={label}>
                <StepLabel>{label}</StepLabel>
                <StepContent>
                  <Typography>{getStepContent(index)}</Typography>
                  <div className={classes.actionsContainer}>
                    <div>
                      <Button
                        disabled={activeStep === 0}
                        onClick={this.handleBack}
                        className={classes.button}
                      >
                        Back
                      </Button>
                      <Button
                        variant="contained"
                        color="primary"
                        onClick={this.handleNext}
                        className={classes.button}
                      >
                        {activeStep === steps.length - 1 ? "Finish" : "Next"}
                      </Button>
                    </div>
                  </div>
                </StepContent>
              </Step>
            ))}
          </Stepper>
          {activeStep === steps.length && (
            <Paper square elevation={0} className={classes.resetContainer}>
              <Typography>Thank you for getting to know us better.</Typography>
              <Button
                onClick={this.handleReset}
                className={classes.button}
                color="secondary"
              >
                Click to end
              </Button>
            </Paper>
          )}
        </Grid>
      </div>
    );
  }
}

export default withStyles(styles)(About);

```

To navigate through contents using Steppers, you need to set up the state to track your navigation. And this state is manipulated while doing the navigation. With the `About` component, the contents are generated using two methods; `getSteps` generating the header and `getStepContent` gives the content at a particular step index. Finally, the component gets exported.


### Setting up routes

Now that you have the HomePage and About components to be used as pages, you need to set up routes. In `App.js` file, import Routes from `react-router-dom` and also import HomePage and About components  as shown below;

```js
//... Other Imports
import { Route} from "react-router-dom";
import HomePage from "./pages/HomePage/HomePage";
import About from "./pages/About/About";
``` 
Now, you can clean up the `App` class to hold the routes and other components as follows.

```js
class App extends Component {
  render() {
    return (
      <div>
        <NavBar/>
        <Route path="/" exact component={() => <HomePage/>}/>
        <Route path="/about" component={About} />
      </div>
    );
  }
}
export default App;
```

### Additional Touches

Here, you are adding a top margin to the entire application by updating the `App.js ` file to add a simple CSS to the parent element.

```js
// ... some components and module imports

const divStyle = {
  marginTop: "65px"
};

class App extends Component {
  
  //... constructor and other methods

  render() {
    return (
      <div style={divStyle}>
        {/*... Other Components and Routes*/}
      </div>
    );
  }
}
export default withRouter(App);
```

Also, you can hide the drawer when you click on About item element in the drawer. Implement this hiding functionality by updating `NavBar.js` file, to include a property to the NavLink that wraps the About item.  

```js
<NavLink 
  {/*Other Props here*/}
  onClick={this.handleDrawerClose}>
    {/*Components here*/}
</NavLink>

```


### Developing the Dashboard component

The Dashboard page will hold a tabular view of the stored data. Implement this tabular view by importing these modules from Material-UI. But before that, you need to create `./Dashboard/Dashboard.js` file in the `pages` folder.

```js
import React from "react";
import { withStyles } from "@material-ui/core/styles";
import Paper from "@material-ui/core/Paper";
import Grid from "@material-ui/core/Grid";
import Table from "@material-ui/core/Table";
import TableBody from "@material-ui/core/TableBody";
import TableCell from "@material-ui/core/TableCell";
import TableHead from "@material-ui/core/TableHead";
import TableRow from "@material-ui/core/TableRow";

const styles = theme => ({
  root: {
    flexGrow: 1,
    marginTop: 30
  },
  paper: {
    padding: theme.spacing.unit * 2,
    textAlign: "center",
    color: theme.palette.text.secondary
  },
  table: {
    minWidth: 700
  },
  row: {
    "&:nth-of-type(odd)": {
      backgroundColor: theme.palette.background.default
    }
  }
});

const CustomTableCell = withStyles(theme => ({
  head: {
    backgroundColor: theme.palette.common.black,
    color: theme.palette.common.white
  },
  body: {
    fontSize: 14
  }
}))(TableCell);

class Dashboard extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      data: []
    };
  }
  render() {
    const { classes } = this.props;
    const dashboardContent =
      this.state.data.length > 0 ? (
        <div>
          <Table className={classes.table}>
            <TableHead>
              <TableRow>
                <CustomTableCell>Upcoming Events</CustomTableCell>
                <CustomTableCell align="right">
                  Number of Participants
                </CustomTableCell>
                <CustomTableCell align="right">Event Date</CustomTableCell>
              </TableRow>
            </TableHead>
            <TableBody>
              {this.state.data.map((row, id) => (
                <TableRow key={id} className={classes.row}>
                  <CustomTableCell component="th" scope="row">
                    {row.eventName}
                  </CustomTableCell>
                  <CustomTableCell align="right">
                    {row.totalParticipants}
                  </CustomTableCell>
                  <CustomTableCell align="right">
                    {row.selectedDate}
                  </CustomTableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </div>
      ) : (
        <h1>You are currently not managing any Event.</h1>
      );
    return (
      <div className={classes.root}>
        <Grid container align="center" justify="center">
          <Paper className={classes.paper}>{dashboardContent}</Paper>
        </Grid>
      </div>
    );
  }
}

export default withStyles(styles)(Dashboard);
```

With all the pages or components, you have implemented, there is a pattern that they all kind of follw; you create a CSS classes reference to style the page, import components from Material-UI, create your React Component and export it by wrapping the React component with `withStyles` higher order component for the CSS styling to take effect. 
And that pattern had been applied to the the Dashboard component as well. 

Here the Dashboard component is handling dynamic rendering of page where a tabular view is created after data is collected using the dialog form is stored. If there is no data a different view with a custom data is displayed.

To make the cells of the table to have a common style, a Higher Order Component(HOC), `CustomTableCell` was created to make use of the custom styles for the cells. Customization like background color for the table head, font-size for the table body has been added to this HOC.  

Now that you have the `Dashboard` component created,  you have to set up a route for it in order to access that page. In your `App.js` file, add this additional route by importing `Dashboard` component first;

```js
<Route path="/dashboard" component={Dashboard} />
```


With the Dashboard created, you need to wire the functionality of collecting the data through the form with the Add Event label. To do so, update the  `ListItem` that contains `Add Event` to 

```js
<ListItem button onClick={this.handleClickOpenDialog}>
  <ListItemIcon>
    <Add />
  </ListItemIcon>
  <ListItemText primary="Add Event" />
</ListItem>
```

The ListItem is wired up to listen to onClick event to fire `this.handleClickOpenDialog` method. Hence you need to implement `handleClickOpenDialog` as a method in the `NavBar` component and it can be implemented as follows;

```js
 handleClickOpenDialog = () => {
    alert("me")
  }
``` 

### Creating Form Component

When you click on Add Event label, an alert dialog is shown. For you to store data, a form needs to be created. In the `components` folder, create a subfolder named `AddEvent` with `AddEvent.js` file. Then add the code below to this file.

```js
import React from "react";
import TextField from "@material-ui/core/TextField";
import Dialog from "@material-ui/core/Dialog";
import DialogActions from "@material-ui/core/DialogActions";
import DialogContent from "@material-ui/core/DialogContent";
import DialogContentText from "@material-ui/core/DialogContentText";
import DialogTitle from "@material-ui/core/DialogTitle";
import Button from "@material-ui/core/Button";

const date = new Date().toDateString();

class AddEvent extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      eventName: "",
      totalParticipants: "",
      selectedDate: date
    };
  }

  handleChange = e => {
    e.persist();
    this.setState({ [e.target.name]: e.target.value });
  };

  handleDateChange = date => {
    this.setState({ selectedDate: date.toDateString() });
  };

  saveData = () => {
    if (this.state.eventName !== "" && this.state.totalParticipants !== "") {
      let data = {
        eventName: this.state.eventName,
        totalParticipants: this.state.totalParticipants,
        selectedDate: this.state.selectedDate
      };

      this.setState(
        {
          eventName: "",
          totalParticipants: "", 
          selectedDate: date.toString()
        });
    }
  };

  render() {
    const { selectedDate } = this.state;
    return (
      <Dialog
        open={true}
        onClose={false}
        aria-labelledby="form-dialog-title"
      >
        <DialogTitle id="form-dialog-title">Adding Event</DialogTitle>
        <DialogContent>
          <DialogContentText>
            Record your events and manage them anywhere, anytime.
          </DialogContentText>
          <form>
            <TextField
              value={this.state.eventName}
              onChange={this.handleChange}
              autoFocus
              margin="dense"
              id="eventName"
              name="eventName"
              label="Event Name"
              type="text"
              fullWidth
            />
            <TextField
              value={this.state.totalParticipants}
              onChange={this.handleChange}
              autoFocus
              margin="dense"
              id="totalParticipants"
              name="totalParticipants"
              label="Total Number of Participants"
              type="number"
              fullWidth
            />
            <MuiPickersUtilsProvider utils={DateFnsUtils}>
              <DatePicker
                margin="dense"
                label="Event Date"
                value={selectedDate}
                onChange={this.handleDateChange}
              />
            </MuiPickersUtilsProvider>
          </form>
        </DialogContent>
        <DialogActions>
          <Button color="secondary">
            Cancel
          </Button>
          <Button color="primary" onClick={this.saveData}>
            SAVE
          </Button>
        </DialogActions>
      </Dialog>
    );
  }
}

export default AddEvent;
```

Here, you are creating a form with Dialog module.  The Dialog module presents DialogActions, where actions can be performed on the dialog, can be positioned. It also contains DialogContent section to hold the actual content, in this case, it is a form, There is also DialogTitle for its caption. 

The form created in the Dialog is made of two TextFields and a DatePicker. The DatePicker by default uses the native date picker. For more advanced use cases, you can make use of material-ui-pickers which provides date and time controls that follow the Material Design Specifications. To use `material-ui-pickers` package  you need to install it using npm command as shown below:

```js
npm i material-ui-pickers
```

Also, this `material-ui-pickers` is designed to use a date management library, such as `moment `, `date-fns`, `luxon` and `dayjs`. Here, you will be using `date-fns`, hence you got to install that as well using the command below;

```js
npm i @date-io/date-fns date-fns@next
```
 
Saving the entered data requires keeping track of each field in the component's state and that is why you have state defined them in the constructor. For you to handle the entered data, two methods `handleChange` and `handleDateChange` are defined where `handleChange` is used on the TextFields to capture the entered data as well as using `handleDateChange` to deal with the date data.  To handle the date, add these three imports;

```js
import DateFnsUtils from "@date-io/date-fns";
import { MuiPickersUtilsProvider, DatePicker } from "material-ui-pickers";
import "date-fns";
```

Finally, `saveData` will be executed to store the data in a data store. For now, it just validates the data and group the captured data into a literal object without saving it in a data store.  The `AddEvent` component will be used in the `NavBar` component so you got to import and use it; 

```js
//...Other imports
import AddEvent from '../AddEvent/AddEvent';

//... styles here

class NavBar extends React.Component {

  //... other methods

  render(){
    return (
       <div className={classes.root}>
        { /*... Other Components*/}
        <AddEvent/>
      </div>
    )
  }
}
```


Adding the AddEvent component automatically shows the dialog since the open property of the Dialog component is to true and onClose property is set to false. This means it will always be opened. In order to control when to open and close it, its state must be managed. Since you are using the `AddEvent` class component in `NavBar` class component, you can manipulate the state of the  Dialog component in `NavBar.js` and then pass the result to the `AddEvent`class component via `props`. In the `NavBar` class component, add openDialog as property to the state with a value of false as demonstrated below. 

```js
openDialog: false
```

Update `handleClickOpenDialog` to show the dialog by setting the value of openDialog to true.  Also, add another method named `handleCloseDialog` in the `NavBar` class component to reset the of the openDialog value to false.

```js
 handleClickOpenDialog = () => {
    this.setState({ openDialog: true });
  };

  handleCloseDialog = () =>{
    this.setState({ openDialog: false });
  }
```

You can now pass the openDialog property to the `AddEvent` class component as discussed earlier. In the `NavBar` class component, add the code below as additional `prop` to `AddEvent` component.

```js
  <AddEvent
    openDialog={this.state.openDialog}
    onCloseDialog={this.handleCloseDialog}
  />
```

In the `AddEvent` class component, update the Dialog module as follows;

```js
<Dialog
  open={this.props.openDialog}
  onClose={this.props.onCloseDialog}
  {/*... Other Props*/}
  >
```

Now that you have the form been shown and closed as expected, the next activity to do is to get the form to save some data. The question that you will be asking is where should this captured data be stored in order to make it accessible to the dashboard to populate its table?

Defining the data-store for the captured data in `App.js` will be very much appropriate. Since `AddEvent` class component is nested in `NavBar` class component. Hence the data-store must be accessible by both `NavBar` and `Dashboard` components so that it can be passed around to where it is needed very most. 

In the `App.js`, you define the data-store and also think about how it could be manipulated.  

```js
constructor(props){
  super(props)
  this.state ={
    data: []
  }
}
```

You have the data-store created. Next is to add functionality to store the data in the created data-store.  Since the data will be captured in the `AddEvent`class component, the functionality can be created in the `App.js` file and pass it down to `AddEvent` class component. In the `App.js` file, add this method to the component;

```js
createEvent = (event, cb) => {
  let newDataSet = [...this.state.data, event];
  this.setState({ data: newDataSet }, () => cb());
};
```

This method accepts the event data and callback method that would be executed after you have successfully saved the data to the dataStore. To make this method executed in the `AddEvent` class component, you have to pass it through `NavBar` using props as shown below'

```js
<NavBar createEvent={this.createEvent} />
```

In the `NavBar` class component, you are passing the receiving props like a property to `AddEvent` ;

```js
<AddEvent
  createEvent={this.props.createEvent}
   {/*... Other Props*/}
/>
```

Now `AddEvent` class component has access to `createEvent` method which needs to be executed after clicking on the SAVE button. In the `AddEvent`  class component, you got to update the `saveData` method to 

```js
saveData = () => {
    if (this.state.eventName !== "" && this.state.totalParticipants !== "") {
      let data = {
        eventName: this.state.eventName,
        totalParticipants: this.state.totalParticipants,
        selectedDate: this.state.selectedDate
      };
      this.props.createEvent(data, () => {
        alert("Data saved");
        this.setState(
          {
            eventName: "",
            totalParticipants: "", 
            selectedDate: date.toString()
          }
        );
        this.props.onCloseDialog();  
      });
    }
  };
```

Here you execute the `createEvent` props on the data collected to save the data and once it is done, a callback function is invoked.  Go ahead to test in your browser. 


**NB**: Notice how you are passing down `createEvent` to every child component until it gets executed. You can imagine how this can get tedious on large apps with many nested components. You might have to pass the object down on props through many layers to get to the component that needs it. This problem is commonly called `prop drilling`. Two popular solutions to this pain point are Redux and React's built-in Context. You can explore them later.


You have saved some data to the data-store but when you visit the dashboard page, the data is not populated in a tabular view. This means that data must be made available in the `Dashboard` component as well.  This where you have to pass down the data-store to the `Dashboard` component.  In the `App.js` the `Dashboard` component route is designed as shown below;

```js
<Route path="/dashboard" component={Dashboard} />
```

For you to be able to pass down the props to the `Dashboard component, you have to change the route to 

```js
<Route
    path="/dashboard"
    component={() => <Dashboard  data={this.state.data} />}/>
```

Now that you have the data passed down to the `Dashboard` component, we have to update the state in the `Dashboard` component to use the incoming data. You can achieve that with this code;

```js
this.state = {
  data: this.props.data
};
```

When the data is successfully saved, you then see an alert box. You replace this with Material-UI's snackbar component.

### Adding Snackbar Component.

Snackbar component presents a single line of text directly related to the operation performed. You can use it to display notifications. Implement Snackbar component by creating a sub-folder in the `component` named `MySnackbarContent` with `MySnackbarContent.js` file. In the `MySnackbarContent.js` file, add the following lines of code.

```js
import React from "react";
import classNames from "classnames";
import CheckCircleIcon from "@material-ui/icons/CheckCircle";
import ErrorIcon from "@material-ui/icons/Error";
import CloseIcon from "@material-ui/icons/Close";
import green from "@material-ui/core/colors/green";
import IconButton from "@material-ui/core/IconButton";
import SnackbarContent from "@material-ui/core/SnackbarContent";
import { withStyles } from "@material-ui/core/styles";

const variantIcon = {
  success: CheckCircleIcon,
  error: ErrorIcon
};

const styles = theme => ({
  success: {
    backgroundColor: green[600]
  },
  error: {
    backgroundColor: theme.palette.error.dark
  },
  icon: {
    fontSize: 20
  },
  iconVariant: {
    opacity: 0.9,
    marginRight: theme.spacing.unit
  },
  message: {
    display: "flex",
    alignItems: "center"
  }
});

const MySnackbarContent = props => {
  const { classes, className} =  props;
  const variant = "success"
  const Icon = variantIcon[variant];

  return (
    <SnackbarContent
      className={classNames(classes[variant], className)}
      aria-describedby="client-snackbar"
      message={
        <span id="client-snackbar" className={classes.message}>
          <Icon className={classNames(classes.icon, classes.iconVariant)} />
          Data successfully added
        </span>
      }
      action={[
        <IconButton
          key="close"
          aria-label="Close"
          color="inherit"
          className={classes.close}
        >
          <CloseIcon className={classes.icon} />
        </IconButton>
      ]}
    />
  );
};

export default withStyles(styles)(MySnackbarContent);

```

The `MySnackbarContent` functional component basically has message that will be displayed and action to close the snackbar. Currently, you have a pre-populated message and IconButton that handle the action of the snackbar. Go ahead to use this component in your project.

In order for this `MySnackbarContent` functional component to be used in the project, it needs to be wrap in Snackbar component from Material-UI. Go ahead to use this in the `AddEvent` class component. However, the root element of `AddEvent` class component is Dialog and nesting `MySnackbarContent` in it is not recommended. Therefore, you need to wrap both `Dialog` and `Snackbar` components in `div` element as shown below.

```js
//... Imports here

// date instance

class AddEvent extends React.Component { 
  // ... Other Component Methods

  render(){
    return (
        <div>
        <Dialog
          open={this.props.openDialog}
          onClose={this.props.onCloseDialog}
          aria-labelledby="form-dialog-title">
            {/*... Other Components*/}
        </Dialog>
        <Snackbar
          anchorOrigin={{
            vertical: "bottom",
            horizontal: "left"
          }}
          open={true}
          autoHideDuration={6000}>
            <MySnackbarContent/>
        </Snackbar>
      </div>
    )
  }
}
```

Here, you are basically wrapping the created `MySnackbarContent` component in `Snackbar` in addition to the already imported `AddEvent` component.  Therefore, you will need to import both Snackbar component from Material-UI and also `MySnackbarContent` component you just created as follows;

```js
import MySnackbarContent from "../MySnackbarContent/MySnackbarContent";
import { Snackbar } from "@material-ui/core";
```

Once everything works perfectly, the snackbar will be shown automatically since the Snackbar component has a property named open and it is set to true. But this Snackbar must be shown only when a successful submission of the form is made. This means the state of snackbar must be controlled. Add extra state property,showSnackbar, with a value of false to the state object in the `AddEvent` class component. You then update the `saveData` method to set `showSnackbar` to `true`;

```js
saveData = () => {
  if (this.state.eventName !== "" && this.state.totalParticipants !== "") {
      let data = {
        eventName: this.state.eventName,
        totalParticipants: this.state.totalParticipants,
        selectedDate: this.state.selectedDate
      };
      this.props.createEvent(data, () => {
        this.setState(
          {
            eventName: "",
            totalParticipants: "", 
            selectedDate: date.toString(),
            showSnackbar: true // updating the showSnackbar state
          }
        );
        this.props.onCloseDialog();  
      });
}
```

What if you want to also show a snackbar after closing the dialog form? In the form dialog, there are two buttons, CANCEL and SAVE. To close the dialog, you could have executed `this.props.onCloseDialog` reference on onClick property but in this case, you have extra functionality to be accomplished by the CLOSE button. 
You can equally create a method to do so. Add a method `handleDialogCancel` to the `AddEvent` class component with the code below;

```js
  handleDialogCancel = () => {
    this.props.onCloseDialog()
    this.setState({ isCanceled: true, showSnackbar:true});
  }
```

Here, you a manipulating a state object's property called isCanceled to a truthy value. Hence you will need to add isCanceled to the state object as a property with a value of false.  Add `handleDialogCancel` method as  a reference to an onClick property of the CANCEL button as shown below;

```js
<DialogActions>
  <Button color="secondary" onClick={this.handleDialogCancel}>
    Cancel
  </Button>
    {/*... Other Components here*/}
</DialogActions>
```

Now what you can do is to show the dialog when it is canceled or when it is saved by updating the Snackbar component in `AddEvent` class component as follows;

```js
{this.state.isCanceled ? (
  <Snackbar
    anchorOrigin={{
      vertical: "bottom",
      horizontal: "left"
    }}
    open={this.state.showSnackbar}
    autoHideDuration={6000}>
    <MySnackbarContent/>
  </Snackbar>
  ) : (
  <Snackbar
      anchorOrigin={{
        vertical: "bottom",
        horizontal: "left"
      }}
      open={this.state.showSnackbar}
      autoHideDuration={6000}>
      <MySnackbarContent/>
  </Snackbar>
)}
```

But there is an issue, same message, and color of dialog box. Customize `MySnackbarContent` component to have a custom message and a color of the dialog box depending on the state of the form whether it was canceled or successfully submitted. This means you have to pass property around the `MySnackbarContent` component. The main properties that you will need are variant and message for the dialog color and the content respectively.
Update `MySnackbarContent` component in the `AddEvent` component to contain both the variant and message as shown below;

```js
{this.state.isCanceled ? (
  <Snackbar
    {/*... Some Props*/}
    >
    <MySnackbarContent
      variant="error"
      message="Form Got Cancelled"
    />
  </Snackbar>
  ) : (
  <Snackbar
    {/*... Some Props*/}
    >
      <MySnackbarContent
        variant="success"
        message="Data Successfully Saved"
       />
  </Snackbar>
)}
```

You have to use the message and variant in the `MySnackbarContent` functional component by updating the component implementation too;

```js
// Some imports

// An Icon definition

// Some Styles

const MySnackbarContent = props => {
  const { classes, className, variant, message } = props;
  const Icon = variantIcon[variant];

  return (
    <SnackbarContent
      className={classNames(classes[variant], className)}
      aria-describedby="client-snackbar"
      message={
        <span id="client-snackbar" className={classes.message}>
          <Icon className={classNames(classes.icon, classes.iconVariant)} />
          {message}
        </span>
      }
      action={[
        <IconButton
          key="close"
          aria-label="Close"
          color="inherit"
          className={classes.close}
        >
          <CloseIcon className={classes.icon} />
        </IconButton>
      ]}
    />
  );
};

export default withStyles(styles)(MySnackbarContent);
```


**NB** Sometimes, the Snackbar component autoHideDuration does not work, so you can manually close with onClose props and then pass a  method reference that hides the snackbar. For instance, this method will hide the snackbar when passed as a reference to Snackbar's onClose property.

```js
  handleCloseSnackbar = () => {
    this.setState({ showSnackbar: false });
  };
```

A lot has been done here using Material-UI to build modern UI for React application by wiring up various components. In the next sections, you will have a look at how you can secure React Applications with Auth0.  

## Securing Your React App with Auth0

You have a working React App. In this section, you will learn how to secure React application with Auth0.  For those of you who don't know much about Auth0, you can read more about it from its [official website](https://auth0.com/). In using Auth0 to secure your React App, it involves Sign up for Auth0, Create Auth0 App and Setup Configuration Values.

Visit the website to create an account by following the instructions page by page. Once you have finished creating your account, Auth0 dashboard page will be launched. There you create the Auth0 app which points to the React app.  To create an Auth0 app on the dashboard click on New Application then you choose a name for the app, say `react-material-ui` for instance and then select Single Page Applications(SPA's) as the type of application since React is used in creating SPAs. Finally, there is a widget that asks you the technology you are using to create your application. Since you are using React, you have to select React. Then a page is presented with tutorials on how to setup Auth0 with React Application.  Instead of copying and pasting directly, you do something different but you can still go ahead with the tutorials.

Still, on Auth0 dashboard, click on Applications and then select the application you just created. There you have an overview of the Auth0 app you created. Under settings, you have default settings for SPA's which includes, name, domain, client id, client secret, etc.` You are going to be using some of these settings in your code to configure your app to use Auth0, so you need to take notice of these. 

### Integration Auth0 Authentication in React App

Auth0 provides API's to handle authentication and authorization for your applications. Here, you will be using the Auth0 authentication in your application to handle users to log in with their credentials. To do you so you will need a package called `auth0.js` that contains functions to interact with Auth0. Install this package using the command `npm install auth0-js`

Once you have it installed, you have to configure your application to be identified by Auth0. This why you created the Auth0 App. This has some information that you can use in your application thus linking your App to Auth0. For this, you have to create a file that would hold your Auth0 App information. Preferred file for this kind of task is environment variable file. Create an environment variable file as `.env` at the root of your project. In that file, you are going to specify a few variables using certain information from the Auth0 App settings as demonstrated below

```bash
REACT_APP_AUTHO_DOMAIN=xxxx

REACT_APP_AUTHO_CLIENTID=xxx

REACT_APP_AUTHO_CALLBACKURL=http://localhost:3000/callback
```

Here, you are specifying the domain, client id, and callback URL. You can get the domain as well as the client id from the settings of the Auth0 App. Once you get them, replace `xxx` with those values respectively. Also in the same settings, fill the field for , Allowed Callback URLs,  with http://localhost:3000/callback. This is the URL that the user will be redirected to after the user is authenticated. 

A very quick notice, you can see that the environment variables start with REACT_APP. This is how Create-React-App` expects the variables to be stored in order for it to automatically expose those variables.

With the help of Auth0 package, you can now use the `.env` information to interact with Auth0. In the `src` folder of your application create a folder called `service` which will hold a `Auth.js` file. In the `Auth.js` file, add these code;

```js
import auth0 from "auth0-js";

export default class Auth {
  constructor(history) {
    this.history = history;
    this.auth0 = new auth0.WebAuth({
      domain: process.env.REACT_APP_AUTHO_DOMAIN,
      clientID: process.env.REACT_APP_AUTHO_CLIENTID,
      redirectUri: process.env.REACT_APP_AUTHO_CALLBACKURL,
      responseType: "id_token",
      scope: "openid profile"
    });
  }

  getProfile = () => {
    return this.profile;
  };

  getIdToken = () => {
    return this.idToken;
  };

  isAuthenticated = () => {
    return new Date().getTime() < this.expiresAt;
  };

  signIn = () => {
    this.auth0.authorize();
  };

  handleAuthentication = () => {
    this.auth0.parseHash((err, authResult) => {
      if (err) {
        this.history.push("/");
      }
      if (authResult && authResult.idToken) {
        this.setSession(authResult);
        this.history.push("/");
      }
    });
  };

  signOut = () => {
    this.idToken = null;
    this.profile = null;
    this.expiresAt = null;
    this.auth0.logout({
      clientID: process.env.REACT_APP_AUTHO_CLIENTID,
      returnTo: "http://localhost:3000"
    });
  };

  setSession = authResult => {
    this.idToken = authResult.idToken;
    this.profile = authResult.idTokenPayload;
    this.expiresAt = authResult.idTokenPayload.exp * 1000;
  };
}
```
Here, you began by importing  `auth0-js` package and then declared `Auth` class. This class is constructed by accepting React-router history hence you can perform routing functionality like redirects here. Also, during the construction of the Auth class, you are instantiating the auth0.webAuth that accepts options object with `domain` as a key and its value reference the domain environment variable and the list continues for clientID and redirectUri.  Also, the options object has responseType which gives the type of response after user authentication. Here the responseType is an d_token which give you a JWT token to the authenticate the user after they log in. The last but not the least option is the scope which specify permission. The kind of permission to be used here is `openid` and would like to obtain basic information of the user, thus the user's profile such as name, picture, etc.  

The Auth class has  `getProfile`, `getIdToken`, `isAuthenticated`, `signIn`, `handleAuthentication`, `signOut` and `setSession` methods which use class property syntax for their definitions. And their names depict their function. For instance `signIn` method uses auth0 authorize method to log in the user. 0

To use this class in other components, you need to wire it up with the app so other components can use its instance. This can be done in the `App.js` and then pass it down to other components.  Open the `App.js` file and import and instantiate the `Auth` class in the constructor.

The `HomePage` component has the login button and for the user to login with Auth0, you need to pass that instance to the HomePage as props. 

```js
//... Other Imports Here
import Auth from './service/Auth'

//... Styles Here

class App extends Component {

  constructor(props){
    super(props)
    this.state ={
      data: []
    }

    this.auth = new Auth(this.props.history);
  }
  //...  Other Method
  render() {
    return (
      <div style={divStyle}>
        {/*... Other Components */}
        <Route path="/" exact component={() => <HomePage auth={this.auth}/>}/>
        {/*... Other Routes */}
      </div>
    );
  }
}
```

Now in the `HomePage` component, you can then pass the incoming prop, auth's signIn method as a reference to the onClick property on Button component as shown below 

```js
<Button
  {/*... Other Props */}
  onClick={this.props.auth.signIn}>  
  Login
</Button>
```

Go ahead and test the login functionality with Auth0. It works perfectly, but wait! After login, the page hangs on to an empty page with a long string value in the browser address bar. That long string value is the result from authenticating the user and we have to handle that. Well, you remember while specifying the environment variables, you had a callback url. That needs to be executed after a successful login. What you can do now is to create such url but URL in react must come with a component so you need to create a component for this functionality. 

Go ahead to create a component named `Callback` in your components folder.  In that `Callback.js` file add these code;

```js
import React, { Component } from "react";
import { withRouter } from "react-router-dom";

class Callback extends Component {
  componentDidMount() {
    this.props.auth.handleAuthentication();
  }

  render() {
    return <p>Loading profile...</p>;
  }
}

export default withRouter(Callback);

```

This component accepts auth props and then executes its `handleAuthentication` method. In order for this to be executed after the user is authenticated, you have to set it up as a route. In the `App.js` file setup another route as shown below;

```js
//... Other Imports Here
import Callback from "./components/Callback";


//... Styles Here

class App extends Component {
  //...  Other Methods
  render() {
    return (
      <div style={divStyle}>
        {/*... Other Components and Routs */}
        <Route path="/callback"  component={() => <Callback auth={this.auth}/>}/>
      </div>
    );
  }
}
```

Now after the login is successful, the user is redirected to Callback component.

Now once you are authenticated, you can use Auth0 functionality to achieve authorization such as not allowing users to visit the dashboard page without being authenticated or even hiding the login button after login. 

  1. Preventing user from accessing the dashboard page 

This is pretty much simple, you have to call the `isAuthenticated` method which gives a boolean value. So in the `App.js` update the Dashboard Route to;

```js
 <Route
    path="/dashboard"
    component={() =>
      this.auth.isAuthenticated() 
        ? <Dashboard auth={this.auth} data={this.state.data} />
        : <Redirect to="/" />
    }
/>
```

You are just redirecting the user to the homepage if the user is not logged in. That means you have to also import the Redirect module from `react-router-dom`.

  2. Hiding the Login button after login

After the user is logged in the button must be hidden and that can be achieved simply by rendering null if the user is logged in else render the button. update the Button section of the  `Homepage.js` to the code below;

```js
{this.props.auth.isAuthenticated() 
  ? null
  : <Button
      variant="contained"
      color="primary"
      onClick={this.props.auth.signIn}
    >                       
      Login
    </Button>
}
```

  3. Hiding `Add Event`, `Logout` and `My Account` labels on the NavBar Component
 
The NavBar houses Add Event, Logout and My Account labels. The `Add Event` label shows the addEvent dialog resides in the NavBar component.  That item should only be shown when the user is logged in else show nothing. You got to update that portion of code as well. Before that, you need to pass the auth instance to the NavBar component through React props.
 Therefore you have to update the Navbar component in `App.js` to
 
 ```js
 <NavBar createEvent={this.createEvent} auth={this.auth}/>
 ```

In the `NavBar.js` file, update the ListItem that has the `Add Event` label to;

```js
{
  this.props.auth.isAuthenticated()
  ? <ListItem button onClick={this.handleClickOpenDialog}>
      <ListItemIcon>
        <Add />
      </ListItemIcon>
      <ListItemText primary="Add Event" />
    </ListItem>
  : null
}
```

The Logout and My Account labels are shown in the dropdown menu.  The entire block of code from <IconButton> to </Menu>  in the NavBar component should be updated to;

```js
{
  this.props.auth.isAuthenticated()
  ?(
    <div>
      <IconButton
        onClick={this.handleMenuOpen}
        color="inherit">
        <AccountCircle />
      </IconButton>
      <Menu
        anchorOrigin={{
          vertical: "top",
          horizontal: "right"
        }}
        anchorEl={this.state.anchorEl}
        open={showPopOver}
        onClose={this.handleMenuClose}
        >
        <MenuItem>
          <NavLink
            to="/account"
            style={{ textDecoration: "none", color: "black" }}>
            My Account
          </NavLink>
        </MenuItem>
        <MenuItem>Logout</MenuItem>
    </Menu>
    </div>
  )
  : null
}
```
Thus the IconButton that hold the My Account and Logout labels should not be shown when user is not logged in.

You can now wire up the Logout functionality to the Logout MenuItem by just referencing `this.props.auth.signOut` method on the auth instance to the onClick property of the MenuItem as shown below;

```js
 <MenuItem
    onClick={this.props.auth.signOut}>
    Logout
  </MenuItem>
```

When you click on My Account an empty page is shown.  Go ahead to implement a component for that page.

### Implementing the Account component

This Account component will be made up of a Card component from Material-UI. Card component is also made of CardHeader for displaying caption, CardMedia to display any media content. CardContent to hold the main content and CardActions will be used in case of performing any action related to the card module. In the `pages` sub-folder create a sub-folder named `Account`. In the newly created `Account` folder create `Account.js` file and add these code to it. 


```js
import React from "react";
import {withStyles} from "@material-ui/core/styles";
import classnames from "classnames";
import Card from "@material-ui/core/Card";
import CardHeader from "@material-ui/core/CardHeader";
import CardMedia from "@material-ui/core/CardMedia";
import CardContent from "@material-ui/core/CardContent";
import CardActions from "@material-ui/core/CardActions";
import Collapse from "@material-ui/core/Collapse";
import IconButton from "@material-ui/core/IconButton";
import Typography from "@material-ui/core/Typography";
import ExpandMoreIcon from "@material-ui/icons/ExpandMore";
import Grid from "@material-ui/core/Grid";

const styles = theme => ({
  root: {
    flexGrow: 1,
    marginTop: 30,
  },
  card: {
    maxWidth: 400
  },
  media: {
    height: 0,
    paddingTop: "56.25%"
  },
  actions: {
    display: "flex"
  },
  expand: {
    transform: "rotate(0deg)",
    marginLeft: "auto",
    transition: theme.transitions.create("transform", {
      duration: theme.transitions.duration.shortest
    })
  },
  expandOpen: {
    transform: "rotate(180deg)"
  }
});
class Account extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      expanded: false,
      profile: {},
      imagePlaceHolder:"./placeholder.png"
    };
  }

  componentDidMount() {
    let profile = this.props.auth.getProfile()
    this.setState({ profile, imagePlaceHolder: profile.picture })
  }

  handleExpandClick = () => {
    this.setState(state => ({ expanded: !state.expanded }));
  };

  render() {
    const { classes } = this.props;
    const { profile } = this.state;
    return (
      <div className={classes.root}>
        <Grid container alignItems="center" justify="center">
          <Card className={classes.card}>
            <CardHeader title={profile.nickname} />
            <CardMedia
              className={classes.media}
              image={this.state.imagePlaceHolder}
              title={profile.name}
            />
            <CardContent>
              <Typography variant="h5" gutterBottom={true}>
                Other Profile Data
              </Typography>
            </CardContent>
            <CardActions className={classes.actions} disableActionSpacing>
              <IconButton
                className={classnames(classes.expand, {
                  [classes.expandOpen]: this.state.expanded
                })}
                onClick={this.handleExpandClick}
                aria-expanded={this.state.expanded}
                aria-label="Show more"
              >
                <ExpandMoreIcon />
              </IconButton>
            </CardActions>
            <Collapse in={this.state.expanded} timeout="auto" unmountOnExit>
              <CardContent>
                <Typography component={"span"} variant={"body2"}>
                  <pre>{JSON.stringify(profile, null, 2)}</pre>
                </Typography>
              </CardContent>
            </Collapse>
          </Card>
        </Grid>
      </div>
    );
  }
}
export default withStyles(styles)(Account);

```

Most of the code here won't be that new to you. You are following the same style of writing code where you have imported the modules you will need to create your card, your CSS-in-JS named as style which is basically providing styling to component and few methods to be rendered on this component as well.  One of the most essential takeaways would be image rendering in card component especially when you are retrieving the image from a particular web service, you will need a default image to be rendered and then later be updated with the image that would be fetched from the web service.

This account component retrieves the logged in user's profile and then outputs the details in the card as demonstrated above. 

Once you have this account setup, you will have to import it in your root component, that's the `App.js` file and create its route as shown below;

```js
// ... other imports ...
import Account from "./pages/Account/Account";

class App extends Component {
  // ... constructor
  render() {
    return (
      <div style={divStyle}>
        {/*other ... routes */}

        <Route
          path="/account"
          component={() =>
           this.auth.isAuthenticated() 
            ? <Account auth={this.auth}/>
            : <Redirect to="/" />
          }
        />
      </div>
    );
  }
}
```

You can now test your `My Account` link by clicking on it to route to `/account`. 

### Implementing silent authentication

If you have noticed, anytime you refresh the browser even though you are logged in, you are automatically logged out. Their reason is after the user is logged in, the data from the Auth0 response is then handled by `handleAuthentication` method in the `Auth.js` file.  The data is currently stored in-memory of the class properties and that does not store the user session permanently. 

Options like localStorage have been one of the means to store such user information permanently but they have their own issues in terms of security.  Auth0 recommends an approach called [silent authentication](https://auth0.com/docs/api-auth/tutorials/silent-authentication) to check if the user still has a session or lost session. In this section, you are going to implement such a feature in this sample project. 

In your `Auth.js` class, add this method;

```js
silentAuth() {
  return new Promise((resolve, reject) => {
    this.auth0.checkSession({}, (err, authResult) => {
      if (err) return reject(err);
      this.setSession(authResult);
      resolve();
    });
  });
}
```
By default JWT from Auth0 expires after 3600 seconds which is about 10 hours hence the user must be logged in for such period.  To still make user logged in, you make HTTP call behind the scene using Auth0's `checkSession` method to check if the current user is still having a session on Auth0 server and if so then the user can still access the page else, you are logged out. 

When and where then do you call this method? This must be called anytime there is a request and since request are handled by routes, you can make use of the `silentAuth` method in `App.js` since that is where all Routes are defined.
In the `src/App.js` file update the code as follows;

```js
// ... other imports
import {Route, withRouter} from 'react-router-dom';

class App extends Component {
  // ... constructor here 
  async componentDidMount() {
    if (this.props.location.pathname === '/callback') return;
    try {
      await auth0Client.silentAuth();
      this.forceUpdate();
    } catch (err) {
      if (err.error !== 'login_required') console.log(err.error);
    }
  }

  // ... render
}

export default withRouter(App);
```

Here, you defined what to do when your app loads (componentDidMount):
*  If the incoming route is `/callback`, the app does nothing. And that is expected behavior because, `/callback` route, is called after the authentication process. In this case, you can leave the Callback component to handle the process.

* If the requested route is anything else, the app wants to try a silentAuth. Then, if no error occurs, the app calls forceUpdate so the user can see whatever they asked for.

* If there is an error on the silentAuth, the app checks if the error is different than login_required. If this is the case, the app logs the problem. Otherwise, the app does nothing because it means the user is not signed in 


Also, you are enclosing your App class inside the withRouter function so you can check what route is being called using this.props.location.pathname. Without withRouter, you wouldn't have access to the location object.


With all these changes made and to make this method work as expected, you have to do few changes to your Auth0 App settings. In your Auth0 App settings, add these changes;
  1.  Allowed Web Origins: As your app is going to issue an AJAX request to Auth0, you will need to add http://localhost:3000 to this field. Without this value there, Auth0 would deny any AJAX request coming from your app.

  2. Allowed Logout URLs: To enable users to end their session at Auth0, you will have to call the [logout endpoint](https://auth0.com/docs/logout#log-out-a-user). Similarly to the authorization endpoint, the log out endpoint only redirects users to whitelisted URLs after the process. As such, you will have to add http://localhost:3000 in this field too.


After updating these fields, you can hit the Save Changes button. Then, the last thing you will have to do before focusing in your app's code is to replace the development keys that Auth0 is using to enable users to authenticate through Google.


You might not have noticed but, even though you didn't configure anything related to Google in your Auth0 account, the social login button is there and works just fine. The only reason this feature works out of the box is that Auth0 auto-configure all new accounts to use development keys registered at Google. However, when developers start using Auth0 more seriously, they are expected to replace these keys with their own. And, to force this, every time an app tries to perform a silent authentication, and that app is still using the development keys, Auth0 returns that there is no session active (even though this is not true).

So, to change these keys, move to [the Social Connections on your dashboard](https://manage.auth0.com/#/connections/social), and click on Google. There, you will see two fields among other things: Client ID and Client Secret. This is where you will insert your keys. To get your keys, please, read [the Connect your app to Google documentation provided by Auth0](https://auth0.com/docs/connections/social/google).

**Note:** If you don't want to use your Google keys, you can deactivate this social connection and rely only on users that sign up to your app through Auth0's Username and Password Authentication.



## Conclusion

Congratulations, you have come a long way to get started with the basics of using Material-UI in React applications. You will bear with me that not all the components that come with Material-UI were covered but you can use the same pattern of importing components, defining styles for components and using components as well as working with their props and finally enclosing your component class inside the withStyles for the style to have effect on various components that used them to build any React application using Material-UI. 

Also, you lately wired up the application to use Auth0 for authentication and authorization. Continue to explore more of how Auth0 can help you build well-secured applications.

Also, if you need help, do not hesitate to leave a message on the comments section down below. Have fun with it, thanks. 
