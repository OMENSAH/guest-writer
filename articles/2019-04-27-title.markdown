---
layout: post
title: "Developing Modern Apps with React Material"
description: "React components that implement Google's Material Design"
date: "2019-04-27 08:30"
author:
  name: "Oliver Mensah"
  url: "OliverMensahDev"
  mail: "olivermensah96@gmail.com"
  avatar: "https://twitter.com/OliverMensahDev/profile_image?size=original"
related:
- 2017-11-15-an-example-of-all-possible-elements
---

**TL:DR:** In this article, you will learn about the basic concepts of React Material-UI while developing a simple event management dashboard.

## Prerequisites

In order for you to follow the walk-through on how to setup Material-UI library in any React-based web applications, it is recommended to have a prior experience working with [React](https://reactjs.org/).

However, if this is the first working with `React` but you have been doing web development with vanilla JavaScript in general, that's fine. To get started with the tutorial you need to have Node.js and NPM installed on your development environment. If you don't, kindly [follow these instructions on the official documentation to install Node.js](https://nodejs.org/en/download/). Having Nod.js installed means you have NPM as well since NPM comes with Node.js. 

Finally, the workflow of building React applications has been enhanced with Command Line Interface(CLI) tool which means you are going to be working from your terminal very often. Get access to that and let's get started.

## What You Will Build

After going you have been familiarized with the basic concepts of Material-UI, you will be working on a sample project that utilizes most of the React Material-UI components. This project is a simple event management application that allows registered users to store an event they have hosted. A user is presented with a page to sign up on the first time using `Auth0`. After you are authenticated as a user with `Auth0`, you then have access to an account and dashboard page as well as form dialog. The account page reveals your account details from `Auth0` while the dashboard page presents your recorded events using the form dialog.

## React Material-UI Introduction

React Material-UI is the world's most popular React UI framework according to [the official website](https://material-ui.com/). Basically, it is made of React components that implement Google's Material Design. 

With React Material UI, you can easily make use of these Material Design elements from Google in your React based applications. Since it is made for building good looking applications, it provides other utilities like `Icons` and `Themes` which you can add to your applications. 


## Setting up Material-UI with React.

To get started with Material-UI, you have to add it as a dependency to your `React` project. Let's first create a `React` project with [create-react-app](https://facebook.github.io/create-react-app/), a tool that is developed and maintained by facebook team for creating pre-configured React project. 

If you don't have it installed in your development environment, you need to. As discussed earlier; you need `Node.js` installed which comes with a utility called `NPM` that allows making use of JavaScript packages easier. Let's use this `NPM` to install the create-react-app package. 

```bash
npm i -g  create-react-app
```

**NB::** If you get permission issues then run this command us an admin or root user. 

With `create-react-app` installed, go ahead to create the `React` project. You can achieve this with any of these instructions;

1. Create a folder and navigate to such a folder with the `cd ` terminal utility function.

```bash
create-react-app .
```

2. Create project with a given folder name

```bash
create-react-app folderName 
```

**NB::** Replace folderName with the name of a folder you will choose.

### Cleaning App The Generated Boilerplate.

Running the `create-react-app` command will generate a pre-configured React project. And depending on your project scope, some of the files will not be needed hence you need to clean up the project. Thus you just use what you need but you can go ahead without cleaning up some of these files. To clean up the project, you will get rid of `App.test.js`, `logo.svg`, `serviceworkers.js` files in `./src` folder. Also, remove the content of `App.css`, `index.css` and update `index.js` to have the content below.

```js
import React from 'react';
import ReactDOM from 'react-dom';
import './index.css';
import App from './App';

ReactDOM.render(<App />, document.getElementById('root'));
```

Also, update the `./src/App.js` to the content below;

```js
import React from 'react';
import './App.css';

function App() {
  return (
    <div>
    </div>
  );
}

export default App;
```

Finally, you can test the project to make sure everything works fine. By issuing `npm start` command at the project's root directory in your terminal, it must be served on development server via `http://localhost:3000/`. This must output empty content in the browser and also check the browser console to see if there is no error. 

### Installing and Working with Material-UI

Adding Material-UI library to `React` project is the same as adding other libraries to `React` project.  You can go ahead to add `Material-UI` to your project with the command below.

```bash
npm install @material-ui/core 
```

Now that you have `Material-UI` added to your project, you have to use some of the components that come with.  For instance, let's just add `Button` component from `Material-UI` to the project you created. In your `./src/App.js` file, 

```js
import React from 'react';
import './App.css';
import Button from '@material-ui/core/Button';

function App() {
  return (
    <div>
      <Button variant="contained" color="primary">Test</Button>
    </div>
  );
}

export default App;
```

You just added `Button` component from the `Material-UI` from the library. You might notice that the `Button` component includes props like:
  1. variant: provides the visual style of the component. This can be either contained, outlined, fab.
  2. color: gives that button background color. It can be either primary, secondary, or default.

Most of these props will be covered later. However, you can explore the properties of each component by visiting the `Material-UI Component API` documentation.  For instance the `Button Component API` has its documentation available at [https://material-ui.com/api/button/](https://material-ui.com/api/button/). To see other component's API, go through `Component API` item on the drawer of [Material-UI Website](https://material-ui.com).


### Installing and Working with Icons

`React Material-UI` provides pre-built icons that you can install and use in your project. You add these prebuild SVG icons using `@material-ui/icons` package.  Go ahead to install the package with this command;

```bash
npm install @material-ui/icons
```
After importing `info` icon to the project. The `App.js` file now looks like this;

```js
import React from 'react';
import './App.css';
import Button from '@material-ui/core/Button';
import Info from "@material-ui/icons/Info";

function App() {
  return (
    <div>
      <Button variant="contained" color="secondary">
        <Info/> Test
      </Button>
    </div>
  );
}
export default App
```

**NB** To use a specific icon, you can visit [MATERIAL DESIGN ICONS](https://material.io/tools/icons) to find an icon and then you import it by Pascal-casing its name.


## Implementing the Sample Project

In all `React Material-UI` presents components which would include certain props. Visiting our sample project, the user interface consists of material design elements. You will make use of Material-UI components to display the tabular list of events' data as well create a form to create an event. It will consist of the navigation bar on top which contains navigation drawer, dropdown list as well as navigation links. 

To begin implementing our main sample project, you will need to clean up the `App.js` to:

```js

import React, { Component } from "react";
import "./App.css";

class App extends Component {
  render() {
    return (
      <div>

      </div>
    );
  }
}
export default App;

```

This component will the root component that will hold other components. Let's go ahead to create our first component called the Navigation component.

### Developing the Navigation component 

Adding a navigation bar to the sample application can be implemented using `Appbar` component from the `Material-UI` library. To create this `Navigation` component, create , `components` sub-folder in `src` directory. In the `components` folder create `./Header/Header.js` file and add the code below to the newly created file.

```js
import React from 'react'
import AppBar from '@material-ui/core/AppBar'
import Toolbar from '@material-ui/core/Toolbar'
import Typography from '@material-ui/core/Typography'
const MenuAppBar = () => {
    return(
        <div>
        <AppBar position="fixed">
            <Toolbar>
                <Typography variant="title" color="inherit">
                  Home
                </Typography>
            </Toolbar>
        </AppBar>
        </div>
    )
}
export default MenuAppBar;
```

Here, you are making use of `AppBar`, `Toolbar` and `Typography` components from the Material-UI library to create the navigation bar. The component is then exported.  The sample project has a common navigation bar hence you need to import and use it at the root component, `./src/App.js`.

```js
import React, { Component } from "react";
import "./App.css";

import MenuAppBar from "./components/Header/Header";


class App extends Component {
  render() {
    return (
      <div>
        <MenuAppBar/>
      </div>
    );
  }
}
export default App;
```

You got your first component implemented, you can go ahead to test it your browser. 

There are other components like a drawer that you can add to this Navigation bar. To implement a drawer, import these extra dependencies that will be needed to create a basic drawer in the `MenuAppBar` component.

```js
import Drawer from "@material-ui/core/Drawer";
import ChevronLeftIcon from "@material-ui/icons/ChevronLeft";
import ListItem from "@material-ui/core/ListItem";
import ListItemIcon from "@material-ui/core/ListItemIcon";
import ListItemText from "@material-ui/core/ListItemText";
import Add from "@material-ui/icons/Add";
import Info from "@material-ui/icons/Info";
import Divider from "@material-ui/core/Divider";
import List from "@material-ui/core/List";
import IconButton from "@material-ui/core/IconButton";
import MenuIcon from "@material-ui/icons/Menu";
```

With the drawer, you have to change the `MenuAppBar` from functional component to class component so as to manage some states. The drawer needs to be toggled hence you got to manage its state of it being opened or closed.

```js
class MenuAppBar extends React.Component {
  
  render() {
    return (
      <div>
        <AppBar position="fixed">
          <Toolbar>
            <IconButton
              color="inherit"
              aria-label="Open drawer"
            >
              <MenuIcon />
            </IconButton>

            <Typography variant="title" color="inherit">
              Home
            </Typography>
          </Toolbar>
        </AppBar>
        <Drawer variant="persistent"  anchor="left" open={true}>
          <div>
            <IconButton >
              <ChevronLeftIcon />
            </IconButton>
          </div>
          <Divider />
          <List>
            <ListItem button>
              <ListItemIcon>
                <Info />
              </ListItemIcon>
              <ListItemText primary="About" />
            </ListItem>

            <ListItem button>
              <ListItemIcon>
                <Add />
              </ListItemIcon>
              <ListItemText primary="Add Event" />
            </ListItem>
          </List>
        </Drawer>
      </div>
    );
  }
}
export default MenuAppBar;
```

You just added a Drawer with two list items to the navigation bar. However, you could see the drawer is always open. The point is to click on the  MenuIcon to toggle the drawer. Adding up that functionality of opening or closing a drawer to your `MenuAppBar` component, then you should update `MenuAppBar` class to the code below.

```js
class MenuAppBar extends React.Component {

  constructor(props){
    super(props);
    this.state = {
      openDrawer: false
    }
  }

  handleDrawerOpen = () => {
    this.setState({ openDrawer: true });
  };

  handleDrawerClose = () => {
    this.setState({ openDrawer: false });
  };
  
  render() {
    return (
      <div>
        <AppBar position="fixed">
          <Toolbar>
            <IconButton
            color="inherit"
            aria-label="Open drawer"
            onClick={this.handleDrawerOpen}
            >
             <MenuIcon />
            </IconButton>
           {/* ...Home Typography Here */}
          </Toolbar>
        </AppBar>
        <Drawer 
          variant="persistent" 
          anchor="left" 
          open={this.state.openDrawer}>
          <div>
            <IconButton
              onClick={this.handleDrawerClose}>
              <ChevronLeftIcon />
            </IconButton>
          </div>
            {/* ...Divider Here */}
            {/* ...List of Menu Items Here */}
          </Drawer>
      </div>
    );
  }
}
export default MenuAppBar;
```

**NB**: For brevity, you have some section of the code removed. You got to replace `{/* ...Home Typography Here */}` and other commented sections with the right code from the previous code of that same component section. 

Here, you added `openDrawer` state with a default value of `false` to the component. This state will help keep track of the drawer whether it is opened or closed. The `openDrawer` state is then manipulated by two methods; `handleDrawerOpen` and `handleDrawerClose`. When the `MenuIcon` is clicked, it opens the drawer by referencing `handleDrawerOpen` method.  The drawer has `ChevronLeftIcon (<)`  which when clicked closes the drawer by also referencing `handleDrawerClose` method.  

You will continue to make the navigation bar have a nice interaction. You might have noticed already that when the `MenuIcon` is clicked to open the drawer, the drawer covers the icon and the text on the navigation. You can shift the navigation to the right when the icon is clicked and when it is closed, it should come back to its actual position. This is achieved by just adding some few css styles to the `AppBar `.  [CSS-in-JS](https://material-ui.com/customization/css-in-js/) approach will be used. This uses higher-order component `withStyles` to inject an array of styles into the DOM as CSS using JS.

Before `MenuAppBar` class, add the code below:

```js
const drawerWidth = 240;
const styles = theme => ({
  appBar: {
    transition: theme.transitions.create(["margin", "width"], {
      easing: theme.transitions.easing.sharp,
      duration: theme.transitions.duration.leavingScreen
    })
  },
  appBarShift: {
    width: `calc(100% - ${drawerWidth}px)`,
    marginLeft: drawerWidth,
    transition: theme.transitions.create(["margin", "width"], {
      easing: theme.transitions.easing.easeOut,
      duration: theme.transitions.duration.enteringScreen
    })
  }
});
```

This will help create the styling of shifting the `AppBar` when the drawer is toggled. To use these classes on the `AppBar`, you have to import two components; `classNames` and `withStyles`. The className will also help in adding multiple classes to a component.

```js
import classNames from "classnames";
import { withStyles } from "@material-ui/core/styles";
```

To inject that styles you created to have an effect on the component you have to export `MenuAppBar` as module wrapped with a higher order function as shown below;

```js
export default withStyles(styles)(MenuAppBar);
```

Wrapping the class with `withStyles` passes down `classes` props to that component.  You can access this `classes` props in the `render` method of the component by destructuring the props as shown below;

```js
  const { classes } = this.props;
```

Finally, apply the styles to `AppBar` by including the className below as a prop to `AppBar` component.

```js
className = { classNames(classes.appBar, {[classes.appBarShift]: this.state.openDrawer})}
```


Now it the navigation should look quite better after clicking the MenuIcon. But you can see there is a lot of space between the `Drawer` and the `AppBar`. This can be solved by adding a few styles to some elements.  In your styles, add the following pieces of code:

```js
menuButton: {
    marginLeft: 20,
    marginRight: 20
  },
  drawer: {
    width: drawerWidth,
    flexShrink: 0
  },
  drawerPaper: {
    width: drawerWidth
  },
  drawerHeader: {
    display: "flex",
    alignItems: "center",
    padding: "0 8px",
    ...theme.mixins.toolbar,
    justifyContent: "flex-end"
  }
```

From the above styling, `menuButton` will help create a margin between the menu icon and the header text. `drawer` provides the width of the drawer while  `drawerPaper` and `drawerHeader` helps removes the margin between the drawer and the toolbar.

Add these stylings to the few components elements like the `IconButton` higher order component for `MenuIcon` and that of `Drawer`. Update the `IconButton` right after toolbar to have `className` prop. 

```js
<Toolbar>
  <IconButton
    {/* ...Other Props Here*/}
    className={classNames(
      classes.menuButton,
      this.state.openDrawer
    )}>
    <MenuIcon />
  </IconButton>
    {/* ...Other Components Here*/}
</Toolbar>  
```

Also, the drawer element can be updated to contain these classes and className. Afterward, the parent element of the drawer, div element, must be styled as well.

```js
<Drawer
  {/* ...Other Props Here*/}
  classes={{
    paper: classes.drawerPaper
  }}
  className={classes.drawer}>
  <div className={classes.drawerHeader}>
      {/* ...Other Components Here*/}
  </div>
</Drawer>
```

In all, your `MenuAppBar` component's code must be like this;

```js
import React from "react";
import AppBar from "@material-ui/core/AppBar";
import Toolbar from "@material-ui/core/Toolbar";
import Typography from "@material-ui/core/Typography";
import IconButton from "@material-ui/core/IconButton";
import MenuIcon from "@material-ui/icons/Menu";

import Drawer from "@material-ui/core/Drawer";
import ChevronLeftIcon from "@material-ui/icons/ChevronLeft";
import ListItem from "@material-ui/core/ListItem";
import ListItemIcon from "@material-ui/core/ListItemIcon";
import ListItemText from "@material-ui/core/ListItemText";
import Add from "@material-ui/icons/Add";
import Info from "@material-ui/icons/Info";
import Divider from "@material-ui/core/Divider";
import List from "@material-ui/core/List";

import classNames from "classnames";
import { withStyles } from "@material-ui/core/styles";

const drawerWidth = 240;
const styles = theme => ({
  appBar: {
    transition: theme.transitions.create(["margin", "width"], {
      easing: theme.transitions.easing.sharp,
      duration: theme.transitions.duration.leavingScreen
    })
  },
  appBarShift: {
    width: `calc(100% - ${drawerWidth}px)`,
    marginLeft: drawerWidth,
    transition: theme.transitions.create(["margin", "width"], {
      easing: theme.transitions.easing.easeOut,
      duration: theme.transitions.duration.enteringScreen
    })
  },
  menuButton: {
    marginLeft: 20,
    marginRight: 20
  },
  drawer: {
    width: drawerWidth,
    flexShrink: 0
  },
  drawerPaper: {
    width: drawerWidth
  },
  drawerHeader: {
    display: "flex",
    alignItems: "center",
    padding: "0 8px",
    ...theme.mixins.toolbar,
    justifyContent: "flex-end"
  }
});

class MenuAppBar extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      openDrawer: false
    };
  }

  handleDrawerOpen = () => {
    this.setState({ openDrawer: true });
  };

  handleDrawerClose = () => {
    this.setState({ openDrawer: false });
  };

  render() {
    const { classes } = this.props;

    return (
      <div>
        <AppBar
          position="fixed"
          className={classNames(classes.appBar, {
            [classes.appBarShift]: this.state.openDrawer
          })}
        >
          <Toolbar>
            <IconButton
              color="inherit"
              aria-label="Open drawer"
              onClick={this.handleDrawerOpen}
              className={classNames(classes.menuButton, this.state.openDrawer)}
            >
              <MenuIcon />
            </IconButton>

            <Typography variant="title" color="inherit">
              Home
            </Typography>
          </Toolbar>
        </AppBar>
        <Drawer
          variant="persistent"
          anchor="left"
          open={this.state.openDrawer}
          classes={{
            paper: classes.drawerPaper
          }}
          className={classes.drawer}
        >
          <div className={classes.drawerHeader}>
            <IconButton onClick={this.handleDrawerClose}>
              <ChevronLeftIcon />
            </IconButton>
          </div>
          <Divider />
          <List>
            <ListItem button>
              <ListItemIcon>
                <Info />
              </ListItemIcon>
              <ListItemText primary="About" />
            </ListItem>

            <ListItem button>
              <ListItemIcon>
                <Add />
              </ListItemIcon>
              <ListItemText primary="Add Event" />
            </ListItem>
          </List>
        </Drawer>
      </div>
    );
  }
}
export default withStyles(styles)(MenuAppBar);
```

You are almost done implementing the navigation bar but so far we have not added any navigation links yet.  You have `Home` as normal text on the navigation bar, you can convert it to navigation link. 

Navigation requires routing to different URLs to load a page. However, routing utility does not come with React by default. You have to install a package, `React-Router-Dom` for this. Use the command below to do the installation.

```bash
  npm i react-router-dom
```

Then from `react-router-dom` package, import `NavLink` module into the `MenuAppBar` component to create the link. 

```js
import { NavLink} from "react-router-dom";
```

Wrap the `Home` text with `NavLink` as bellow;

```js
<Typography variant="title" color="inherit">  
  <NavLink
    to="/"
    style={{ textDecoration: "none", color: "white" }}>
    Home
  </NavLink>
</Typography>
```
Few styles have been added to improve the Link. After saving the file and testing in the browser, you will get some errors. This is basically telling us that the whole app is not set up to have routes. To solve this, let's wrap the whole application to use routes. Go to `./src/index.js` and update the contents to;

```js
import React from "react";
import ReactDOM from "react-dom";
import "./index.css";
import App from "./App";
import { BrowserRouter, Route } from "react-router-dom";

ReactDOM.render(
  <BrowserRouter>
    <Route component={App} />
  </BrowserRouter>,
  document.getElementById("root")
);
```
Now when you hover over the home item on the navigation bar it turns into a clickable link.  Lets' create another link item on the navigation bar after `Home` Typography as;

```js
<Typography variant="h6" color="inherit">
  <NavLink
    to="/dashboard"
    style={{ textDecoration: "none", color: "white" }}>
    Dashboard
  </NavLink>
</Typography>
```

After adding `Dashboard` Link, you could see both links are very close to each other. You can space them out by styling. Update your styles to have these two additional properties;

```js
const styles = theme => ({
  //... Other Styles Here
  root: {
    display: "flex",
    flexGrow: 1
  },
  grow: {
    flexGrow: 1,
    marginLeft: 15
  }
})  
```

Then update the following elements, the parent div of the component and the second navigation link item to have the styles that would help in spacing out the two links.

```js
class MenuAppBar extends React.Component {
  //.. Other Component Methods Here
  render(){
    return(
      <div className={classes.root}>
        {/*... Other Components Here*/}
        <Typography 
          variant="h6" 
          color="inherit" 
          className={classes.grow}>
          <NavLink
            to="/dashboard"
            style={{ textDecoration: "none", color: "white" }}
          >
            Dashboard
          </NavLink>
        </Typography>
        {/*... Other Components Here*/}
      </div>
    )
  } 
}
```

Also, in our drawer, the `About` item will be a link to `/about` page hence you need to implement navigation link for that as well. And that's how it looks like after adding the `NavLink`.

```js
<NavLink to="/about" style={{ textDecoration: "none" }}>
  <ListItem button>
    <ListItemIcon>
      <Info />
    </ListItemIcon>
    <ListItemText primary="About" />
  </ListItem>
</NavLink>
```

Lastly, there is one feature on the navigation bar which has not yet been implemented. and that is the dropdown menu which has two items; `Account` and `Logout` items. To implement this, you need to import some components and icons from the `Material-UI` library. 

```js
import AccountCircle from "@material-ui/icons/AccountCircle";
import MenuItem from "@material-ui/core/MenuItem";
import Menu from "@material-ui/core/Menu";
```

From here, you can add these lines of code to your `Toolbar`. In the toolbar, right after the second navigation link, `Dashboard`, add these codes.

```js
<IconButton
  color="inherit">
  <AccountCircle />
</IconButton>
<Menu
  anchorOrigin={{
    vertical: "top",
    horizontal: "right"
  }}
  anchorEl={this.state.anchorEl}
  open={false}>
  <MenuItem>
    <NavLink
      to="/account"
      style={{ textDecoration: "none", color: "black" }}>
      My Account
      </NavLink>
  </MenuItem>
  <MenuItem>Logout</MenuItem>
</Menu>
```

Here, you are using `IconButton` to create popup menu elements. This menu has two elements, `My Account` and `Logout` where `My Account` is a link to `/account` URL. In the menu, there is an `open` property that is currently set to false. Once it is true, the pop will show. This means we have to handle its state as well.

Update the state of the `MenuAppBar` component to have `anchorEl` as state property with a value of null.  

**NB** anchorEl is the DOM elements that will be positioned in the popover. The boolean value can be determined this anchorEL. Thus if `anchorEl` has value that is not null, it means there are items to be displayed in the popover if not return null. Truthy values can then be determined to show or hide the popOver depending on the anchorEl returned value. 

Also, add these two methods to the `MenuAppBar` component to manipulate the state of `anchorEl`

```js
 handleMenuOpen = event => {
    this.setState({ anchorEl: event.currentTarget });
  };

  handleMenuClose = () => {
    this.setState({ anchorEl: null });
  };
``` 

`handleMenuOpen` should be called when the `IconButton` is clicked and `handleMenuClose` executes when the menu closes. You can update both the `Menu` and `IconButton` components to have these functionalities as shown below;

```js
 <IconButton
    {/*...Other Props Here*/}
    onClick={this.handleMenuOpen}
    >
    <AccountCircle />
  </IconButton>
  <Menu
    {/*...Other Props Here*/}
    open={showPopOver} {/* Changed from false to showPopOver */}
    onClose={this.handleMenuClose}>
```

Also, you can observe that the `open` property has the value of `showPopOver` instead of the false value.  This `showPopOver` is obtained from the truthy value of `anchorEl`. Right after destructuring of the props;  `const { classes } = this.props;`, add the code below.

```js
const showPopOver = Boolean(this.state.anchorEl);
```

You have been able to achieve a navigation bar with almost its functionality achieve, later, you will hook in the remaining functionalities.


### Developing the Homepage component

The homepage has just a description of the application as well as a button for the user to login. Let's go ahead to implement the Homepage component. 

In your root directory, create a new folder called `pages`. Create a subdirectory called `HomePage` which will hold `Homepage.js` file. In the newly created file., let's add these content;

```js
import React, { Component } from "react";
import Button from "@material-ui/core/Button";
import Typography from "@material-ui/core/Typography";

import "./HomePage.css";

class HomePage extends Component {
  render() {
    return (
      <div className="container">
        <div className="overlay"/>
        <div className="content">
          <h1>Event Scheme</h1>
          <Typography>
            Let's help you create and manage your events.
          </Typography>
          <Button
            variant="contained"
            color="primary"
            >
            Login
          </Button>
        </div>
      </div>
    );
  }
}
export default HomePage;
``` 

Here, you are using `Button` and `Typography` components from `Material-UI`.
Also, the external CSS file named `HomePage.css` is imported. Create such file in the `HomePage` folder. After creating such file, add these CSS codes to it.

```css
.container {
  height: 100vh;
  display: flex;
  align-items: center;
  color: #fff;
  max-width: 960px;
  padding-left: 1rem;
  padding-right: 1rem;
  margin: auto;
  justify-content: center;
  text-align: center;
}

.overlay {
  height: 100vh;
  position: absolute;
  left: 0;
  width: 100vw;
  z-index: 1;
  background: #225470;
  opacity: 0.85;
}

.content {
  z-index: 3;
}

.content h1 {
  font-size: 50px;
  margin-bottom: 0;
}

.content p {
  font-size: 1.5rem;
  display: block;
  padding-bottom: 2rem;
}
```

### Developing the About component

Adding up the `About` component is just like what you implemented for the `HomePage` component. In your `pages` create another folder called `About`. In that `About` folder create `About.js` file.  With the `About` page, it uses `Stepper` component from `Material UI` to display content through a sequence of logical and numbered steps.  Add the following code this file;

```js
import React from "react";
import { withStyles } from "@material-ui/core/styles";
import Stepper from "@material-ui/core/Stepper";
import Step from "@material-ui/core/Step";
import StepLabel from "@material-ui/core/StepLabel";
import StepContent from "@material-ui/core/StepContent";
import Button from "@material-ui/core/Button";
import Paper from "@material-ui/core/Paper";
import Typography from "@material-ui/core/Typography";
import Grid from "@material-ui/core/Grid";

const styles = theme => ({
  root: {
    flexGrow: 1
  },
  button: {
    marginTop: theme.spacing.unit,
    marginRight: theme.spacing.unit
  },
  actionsContainer: {
    marginBottom: theme.spacing.unit * 2
  },
  resetContainer: {
    padding: theme.spacing.unit * 3
  }
});

function getSteps() {
  return ["About Us", "What We do?", "What Others are Saying?"];
}

function getStepContent(step) {
  switch (step) {
    case 0:
      return `Success Scheme is the world's largest event management technology platform,
       making sure millions of events happening across the globe are well managed. 
       We give event organizers the power to when it comes to event management`;
    case 1:
      return `At Success Scheme, we give power to event organizers when managing their events in just one place. 
      Easier to sync across multiple devices and discovered by millions of people on all social media platforms`;
    case 2:
      return `Try out different ad text to see what brings in the most customers,
              and learn how to enhance your ads using features like ad extensions.
              If you run into any problems with your ads, find out how to tell if
              they're running and how to resolve approval issues. -- John Doe`;
    default:
      return "Unknown step";
  }
}

class About extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      activeStep: 0
    };
  }

  handleNext = () => {
    this.setState(state => ({
      activeStep: state.activeStep + 1
    }));
  };

  handleBack = () => {
    this.setState(state => ({
      activeStep: state.activeStep - 1
    }));
  };

  handleReset = () => {
    this.setState({
      activeStep: 0
    });
  };

  render() {
    const { classes } = this.props;
    const steps = getSteps();
    const { activeStep } = this.state;

    return (
      <div className={classes.root}>
        <Grid container alignItems="center" justify="center">
          <Stepper activeStep={activeStep} orientation="vertical">
            {steps.map((label, index) => (
              <Step key={label}>
                <StepLabel>{label}</StepLabel>
                <StepContent>
                  <Typography>{getStepContent(index)}</Typography>
                  <div className={classes.actionsContainer}>
                    <div>
                      <Button
                        disabled={activeStep === 0}
                        onClick={this.handleBack}
                        className={classes.button}
                      >
                        Back
                      </Button>
                      <Button
                        variant="contained"
                        color="primary"
                        onClick={this.handleNext}
                        className={classes.button}
                      >
                        {activeStep === steps.length - 1 ? "Finish" : "Next"}
                      </Button>
                    </div>
                  </div>
                </StepContent>
              </Step>
            ))}
          </Stepper>
          {activeStep === steps.length && (
            <Paper square elevation={0} className={classes.resetContainer}>
              <Typography>Thank you for getting to know us better.</Typography>
              <Button
                onClick={this.handleReset}
                className={classes.button}
                color="secondary"
              >
                Click to end
              </Button>
            </Paper>
          )}
        </Grid>
      </div>
    );
  }
}

export default withStyles(styles)(About);

```

To navigate through contents using `Steppers`, you need to set up the state to track your navigation. And this state is manipulated while doing the navigation. With the `About` component, the contents are generated using two functions; `getSteps` generating the header and `getStepContent` gives the content at a particular step index. Finally, the component gets exported.


### Setting up routes

Now that you have the `HomePage` and `About` components to be used as pages, you need to set up your routes. 

In `App.js`, import `Routes` from `react-router-dom` as well as `HomePage` and `About` components  as shown below;

```js
//... Other Imports
import { Route} from "react-router-dom";
import HomePage from "./pages/HomePage/HomePage";
import About from "./pages/About/About";
``` 
Now, you can clean up the `App` class to hold the routes and other components with these codes.

```js
class App extends Component {
  render() {
    return (
      <div>
        <MenuAppBar/>
        <Route path="/" exact component={() => <HomePage/>}/>
        <Route path="/about" component={About} />
      </div>
    );
  }
}
export default App;
```

With the routes setup, you can visit the about page by clicking on `About` item in the drawer.

When you visit, the  `About` page in your browser, you can see that its contents have been pushed within the navigation bar. You can solve it by given a margin to the overall application and that can be done within `App.js` instead of doing providing margin per page.  In your `App.js`, add this styling right before the class definition.

```js
const divStyle = {
  marginTop: "65px"
};
```

Add this style to the parent container of the application, `div` at the `App.js ` file.

```js
class App extends Component {
  render() {
    return (
      <div style={divStyle}>
        {/*... Other Components and Routs*/}
      </div>
    );
  }
}
```

### Additional Touches

Now, you click on the `About` link, you can hide the drawer. You just have to implement hiding functionality. To do so go to the `Header.js` file, then add the code below as a property of the `NavLink` that wraps the `About` item.  

```js
<NavLink 
  {/*Other Props here*/}
  onClick={this.handleDrawerClose}>
    {/*Components here*/}
</NavLink>

```


### Developing the Dashboard component

The `Dashboard` page will hold a tabular representation of the stored data. Hence, it will mostly use components that related to the `Table` module. You can start importing the modules from the `Material-UI` that you will need to tabular view. Let's do that together by creating a `./Dashboard/Dashboard.js` file in the `pages` subfolder.

```js
import React from "react";
import { withStyles } from "@material-ui/core/styles";
import Paper from "@material-ui/core/Paper";
import Grid from "@material-ui/core/Grid";
import Table from "@material-ui/core/Table";
import TableBody from "@material-ui/core/TableBody";
import TableCell from "@material-ui/core/TableCell";
import TableHead from "@material-ui/core/TableHead";
import TableRow from "@material-ui/core/TableRow";

const styles = theme => ({
  root: {
    flexGrow: 1,
    marginTop: 30
  },
  paper: {
    padding: theme.spacing.unit * 2,
    textAlign: "center",
    color: theme.palette.text.secondary
  },
  table: {
    minWidth: 700
  },
  row: {
    "&:nth-of-type(odd)": {
      backgroundColor: theme.palette.background.default
    }
  }
});

const CustomTableCell = withStyles(theme => ({
  head: {
    backgroundColor: theme.palette.common.black,
    color: theme.palette.common.white
  },
  body: {
    fontSize: 14
  }
}))(TableCell);

class Dashboard extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      data: []
    };
  }
  render() {
    const { classes } = this.props;
    const dashboardContent =
      this.state.data.length > 0 ? (
        <div>
          <Table className={classes.table}>
            <TableHead>
              <TableRow>
                <CustomTableCell>Upcoming Events</CustomTableCell>
                <CustomTableCell align="right">
                  Number of Participants
                </CustomTableCell>
                <CustomTableCell align="right">Event Date</CustomTableCell>
              </TableRow>
            </TableHead>
            <TableBody>
              {this.state.data.map((row, id) => (
                <TableRow key={id} className={classes.row}>
                  <CustomTableCell component="th" scope="row">
                    {row.eventName}
                  </CustomTableCell>
                  <CustomTableCell align="right">
                    {row.totalParticipants}
                  </CustomTableCell>
                  <CustomTableCell align="right">
                    {row.selectedDate}
                  </CustomTableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </div>
      ) : (
        <h1>You are currently not managing any Event.</h1>
      );
    return (
      <div className={classes.root}>
        <Grid container align="center" justify="center">
          <Paper className={classes.paper}>{dashboardContent}</Paper>
        </Grid>
      </div>
    );
  }
}

export default withStyles(styles)(Dashboard);
```

The code for the `Dashboard` is similar to those we have been implemented earlier. You have a reference for styling the page, importing components, creating the contents and finally wrapping the component with `withStyles` for the styling to take effect. The `Dashboard` component is also dealing with dynamic rendering where a tabular view is created after data is stored from the form dialog. If there is no data a different view with a custom data is displayed.

To make the cells of the table to have a common style, a Higher Order Component(HOC), `CustomTableCell` was created to make use of the customization needed for the cell. Customization like `background` color for the table head, `font-size` for the table body has been added to this HOC.  

Now that you have the `Dashboard` component created,  you have to set up a route for it in order to access that page. In your `App.js` file, add this additional route by importing `Dashboard` component first;

```js
<Route path="/dashboard" component={Dashboard} />
```


For the table to populate content, there must a functionality to store data into the application. If you remember, the application had `Add Event` label on the drawer which will be responsible to open the form dialog to enter the data needed to create the table.  

To do so, update the  `ListItem` that contains `Add Event` to 

```js
<ListItem button onClick={this.handleClickOpenDialog}>
  <ListItemIcon>
    <Add />
  </ListItemIcon>
  <ListItemText primary="Add Event" />
</ListItem>
```

The `ListItem`  now has `onClick` property with `this.handleClickOpenDialog` as a value. Hence you need to implement `handleClickOpenDialog` as a method in the `MenuAppBar` component. Let's add that method.

```js
 handleClickOpenDialog = () => {
    alert("me")
  }
``` 

### Creating Form Component

When you click on `Add Event`, you can now see the alert dialog. For the user to store data, a form needs to be created so such user can input in his/her data before saving. In your `components` folder, create a subfolder named `AddEvent` with `AddEvent.js` file. Then add the code below to this file.

```js
import React from "react";
import TextField from "@material-ui/core/TextField";
import Dialog from "@material-ui/core/Dialog";
import DialogActions from "@material-ui/core/DialogActions";
import DialogContent from "@material-ui/core/DialogContent";
import DialogContentText from "@material-ui/core/DialogContentText";
import DialogTitle from "@material-ui/core/DialogTitle";
import Button from "@material-ui/core/Button";

const date = new Date().toDateString();

class AddEvent extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      eventName: "",
      totalParticipants: "",
      selectedDate: date
    };
  }

  handleChange = e => {
    e.persist();
    this.setState({ [e.target.name]: e.target.value });
  };

  handleDateChange = date => {
    this.setState({ selectedDate: date.toDateString() });
  };

  saveData = () => {
    if (this.state.eventName !== "" && this.state.totalParticipants !== "") {
      let data = {
        eventName: this.state.eventName,
        totalParticipants: this.state.totalParticipants,
        selectedDate: this.state.selectedDate
      };

      this.setState(
        {
          eventName: "",
          totalParticipants: "", 
          selectedDate: date.toString()
        });
    }
  };

  render() {
    const { selectedDate } = this.state;
    return (
      <Dialog
        open={true}
        onClose={false}
        aria-labelledby="form-dialog-title"
      >
        <DialogTitle id="form-dialog-title">Adding Event</DialogTitle>
        <DialogContent>
          <DialogContentText>
            Record your events and manage them anywhere, anytime.
          </DialogContentText>
          <form>
            <TextField
              value={this.state.eventName}
              onChange={this.handleChange}
              autoFocus
              margin="dense"
              id="eventName"
              name="eventName"
              label="Event Name"
              type="text"
              fullWidth
            />
            <TextField
              value={this.state.totalParticipants}
              onChange={this.handleChange}
              autoFocus
              margin="dense"
              id="totalParticipants"
              name="totalParticipants"
              label="Total Number of Participants"
              type="number"
              fullWidth
            />
            <MuiPickersUtilsProvider utils={DateFnsUtils}>
              <DatePicker
                margin="dense"
                label="Event Date"
                value={selectedDate}
                onChange={this.handleDateChange}
              />
            </MuiPickersUtilsProvider>
          </form>
        </DialogContent>
        <DialogActions>
          <Button color="secondary">
            Cancel
          </Button>
          <Button color="primary" onClick={this.saveData}>
            Send
          </Button>
        </DialogActions>
      </Dialog>
    );
  }
}

export default AddEvent;
```

This form is created with `Dialog` module.  The `Dialog` module presents `DialogActions` where actions like closing the `Dialog` are placed. It also contains `DialogContent` holds the actual content, in this case, the `form`. There is also `DialogTitle` for its caption. The form is made of two `TextFields` and a `DatePicker`. The DatePicker by default uses the native date picker. For more advanced use cases, you can make use of `material-ui-pickers` which provides date and time controls that follow the Material Design. To use `material-ui-pickers` package  you need to install it using npm command as shown below:

```js
npm i material-ui-pickers
```

Also, this `material-ui-pickers` is designed to use a date management library, such as `moment `, `date-fns`, `luxon` and `dayjs`. Here, you will be using `date-fns`, hence you got to install that as well using the command below;

```js
npm i @date-io/date-fns date-fns@next
```
 
Saving the entered data requires keeping track of each field in the component's state and that is why you have state defined in the constructor. For you to handle the entered data, two methods `handleChange` and `handleDateChange` are defined where `handleChange` is used on the TextFields to capture the entered data as well as using `handleDateChange` to deal with the date data.  To handle the date, add these three imports;

```js
import DateFnsUtils from "@date-io/date-fns";
import { MuiPickersUtilsProvider, DatePicker } from "material-ui-pickers";
import "date-fns";
```

Finally, `saveData` will be executed to store the data in a data store. For now, it just validates the data and group the captured data into a literal object without saving it in a data store.  The `AddEvent` component will be used in the `MenuAppBar` component so you got to import and use it; 

```js
//...Other imports
import AddEvent from '../AddEvent/AddEvent';

//... styles here

class MenuAppBar extends React.Component {

  //... other methods

  render(){
    return (
       <div className={classes.root}>
        { /*... Other Components*/}
        <AddEvent/>
      </div>
    )
  }
}
```


Now you can see in your browser that the `Dialog` box is automatically shown. This is because `Dialog` component has `open` propert which is currently set to `true` and `onClose` to `false`. This means the state of the `Dialog` must be manipulated to be opened and closed on certain conditions.  Since you are using the `AddEvent` component in `MenuAppBar` component, you can manipulate the state of the  `Dialog` component in `MenuAppBar` component and then pass the result to the `AddEvent` component via props. In the `MenuAppBar` component, add `openDialog` as key to the state object with a value of `false` as demonstrated below. 

```js
openDialog: false
```

Update `handleClickOpenDialog` to show the dialog by setting the value of `openDialog` to ``true`.  Also, add another method named `handleCloseDialog` in the `MenuAppBar` component to reset the of the `openDialog`  value to `false`.

```js
 handleClickOpenDialog = () => {
    this.setState({ openDialog: true });
  };

  handleCloseDialog = () =>{
    this.setState({ openDialog: false });
  }
```

You can now pass the `openDialog` state object key to the `AddEvent` component as discussed earlier. In the ``MenuAppBar` component, add the code below as additional `prop` to `AddEvent` 

```js
openDialog={this.state.openDialog}
onCloseDialog={this.handleCloseDialog}
```

In the `AddEvent` component change the props value of `open` from `true` to `this.props.openDialog` and that of `onClose` from false to `this.props.onCloseDialog` as shown below.  

```js
<Dialog
  open={this.props.openDialog}
  onClose={this.props.onCloseDialog}
  {/*... Other Props*/}
  >
```

Finally, you have the form dialog been controlled by some state values. 

Now that you have the form been shown and closed as expected, the next activity to do is to get the form to save some data you will be entering. The question that you will be asking is where should this captured data be stored in order to make it accessible to the dashboard to populate its table?

Defining the data-store for the captured data in `App.js` will be very much appropriate. Since `AddEvent` component is nested in `MenuAppBar` component. Hence the data-store must be accessible by both `MenuAppBar` and `Dashboard` components so that it can be passed around to where it is needed very most. 

In the `App.js`, let's define the data-store and also think about how it could be manipulated.  

```js
constructor(props){
  super(props)
  this.state ={
    data: []
  }
}
```

You have the data-store created. Next is to add functionality to store the data in the created data-store.  Since the data will be captured in the `AddEvent` component, the functionality can be created in the `App.js` file and pass it down to `AddEvent` component. In the `App.js` file, add this method to the component;

```js
createEvent = (event, cb) => {
  let newDataSet = [...this.state.data, event];
  this.setState({ data: newDataSet }, () => cb());
};
```
This method accepts the event data and callback method that would be executed after you have successfully saved the data to the dataStore. To make this method executed in the `AddEvent` component, you have to pass it through `MenuAppBar` using props as shown below'

```js
<MenuAppBar createEvent={this.createEvent} />
```

In the `MenuAppBar` component, you are passing the receiving props like a property to `AddEvent`;

```js
<AddEvent
  createEvent={this.props.createEvent}
   {/*... Other Props*/}
/>
```

Now `AddEvent` has access to `createEvent` method which needs to be executed after clicking on the `Send` button. In the `AddEvent`  component, you got to update the `saveData` method to 

```js
saveData = () => {
    if (this.state.eventName !== "" && this.state.totalParticipants !== "") {
      let data = {
        eventName: this.state.eventName,
        totalParticipants: this.state.totalParticipants,
        selectedDate: this.state.selectedDate
      };
      this.props.createEvent(data, () => {
        alert("Data saved");
        this.setState(
          {
            eventName: "",
            totalParticipants: "", 
            selectedDate: date.toString()
          }
        );
        this.props.onCloseDialog();  
      });
    }
  };
```

Here you execute the `createEvent` props on the data collected to save the data and once it is done, a callback function is invoked.  Go ahead to test in your browser. 


**NB**: Notice how you are passing down `createEvent` to every child component until it gets executed. You can imagine how this can get tedious on large apps with many nested components. You might have to pass the object down on props through many layers to get to the component that needs it. This problem is commonly called `prop drilling`. Two popular solutions to this pain point are Redux and React's built-in Context. You can explore them later.


You have saved some data to the data-store but when you visit the dashboard page, the data is not populated in a tabular view. This means that data must be made available in the `Dashboard` component as well.  This where you have to pass down the data-store to the `Dashboard` component.  In the `App.js` the `Dashboard` component route is designed as shown below;

```js
<Route path="/dashboard" component={Dashboard} />
```

For you to be able to pass down the props to the `Dashboard component, you have to change the route to 

```js
<Route
    path="/dashboard"
    component={() => <Dashboard  data={this.state.data} />}/>
```

Now that you have the data passed down to the `Dashboard` component, we have to update the state in the `Dashboard` component to use the incoming data. You can achieve that with this code;

```js
this.state = {
  data: this.props.data
};
```

When the data is successfully saved, you then see an alert box. Let's replace this with `Material-UI`'s snackbar component.

### Adding Snackbar Component.

`Snackbar` component presents a single line of text directly related to the operation performed. You can use it to display notifications. Let's implement `Snackbar` component by creating a sub-folder in the `component` named `Snackbar` with `Snackbar.js` file. In the `Snackbar.js` file, add the following lines of code.

```js
import React from "react";
import classNames from "classnames";
import CheckCircleIcon from "@material-ui/icons/CheckCircle";
import ErrorIcon from "@material-ui/icons/Error";
import CloseIcon from "@material-ui/icons/Close";
import green from "@material-ui/core/colors/green";
import IconButton from "@material-ui/core/IconButton";
import SnackbarContent from "@material-ui/core/SnackbarContent";
import { withStyles } from "@material-ui/core/styles";

const variantIcon = {
  success: CheckCircleIcon,
  error: ErrorIcon
};

const styles = theme => ({
  success: {
    backgroundColor: green[600]
  },
  error: {
    backgroundColor: theme.palette.error.dark
  },
  icon: {
    fontSize: 20
  },
  iconVariant: {
    opacity: 0.9,
    marginRight: theme.spacing.unit
  },
  message: {
    display: "flex",
    alignItems: "center"
  }
});

const MySnackbarContent = props => {
  const { classes, className} =  props;
  const variant = "success"
  const Icon = variantIcon[variant];

  return (
    <SnackbarContent
      className={classNames(classes[variant], className)}
      aria-describedby="client-snackbar"
      message={
        <span id="client-snackbar" className={classes.message}>
          <Icon className={classNames(classes.icon, classes.iconVariant)} />
          Data successfully added
        </span>
      }
      action={[
        <IconButton
          key="close"
          aria-label="Close"
          color="inherit"
          className={classes.close}
        >
          <CloseIcon className={classes.icon} />
        </IconButton>
      ]}
    />
  );
};

export default withStyles(styles)(MySnackbarContent);

```

The `MySnackbarContent` component basically has `message` that will be displayed and `action` to close the snackbar. Currently, you have a pre-populated message and `IconButton` that handle the action of the snackbar. Go ahead to use this component in your project.

In the `AddEvent` component, you need to include the snackbar and that can be achieved by wrapping the ` MySnackbarContent` in `Snackbar` component. 
However, the root element of `AddEvent` component is `Dialog`, to add `Snackbar` component, you need to wrap both `Dialog` and `Snackbar` components in `div` element as shown below.

```js
//... Imports here

// date instance

class AddEvent extends React.Component { 
  // ... Other Component Methods

  render(){
    return (
        <div>
        <Dialog
          open={this.props.openDialog}
          onClose={this.props.onCloseDialog}
          aria-labelledby="form-dialog-title">
            {/*... Other Components*/}
        </Dialog>
        <Snackbar
          anchorOrigin={{
            vertical: "bottom",
            horizontal: "left"
          }}
          open={true}
          autoHideDuration={6000}>
            <MySnackbarContentWrapper />
        </Snackbar>
      </div>
    )
  }
}
```

You can see view is using `Snackbar` and `MySnackbarContentWrapper`, you will have to import them into `AddEvent` component as demonstrated below:

```js
import MySnackbarContentWrapper from "../Snackbar/Snackbar";
import { Snackbar } from "@material-ui/core";
```

The snackbar is showing but it is supposed to be shown after successful submission of the form. 
This means the state of snackbar must be controlled. Add extra state property,`showSnackbar`, with a value of `false` to the state object in the `AddEvent` component. Let's update the `saveData` method to set `showSnackbar` to `true`;

```js
saveData = () => {
  if (this.state.eventName !== "" && this.state.totalParticipants !== "") {
      let data = {
        eventName: this.state.eventName,
        totalParticipants: this.state.totalParticipants,
        selectedDate: this.state.selectedDate
      };
      this.props.createEvent(data, () => {
        this.setState(
          {
            eventName: "",
            totalParticipants: "", 
            selectedDate: date.toString(),
            showSnackbar: true // updating the showSnackbar state
          }
        );
        this.props.onCloseDialog();  
      });
}
```

What if you want to also show a snackbar after closing the dialog form? In the form dialog, there are two buttons, `CANCEL` and `SEND`. To close the dialog, you can just use  `this.props.onCloseDialog` reference on `onClick` props but in this case, you have extra functionality to be accomplished by the `CLOSE` button. 
You can equally create a method to do so. Let's add a method `handleDialogCancel` to the `AddEvent` component with the code below;

```js
  handleDialogCancel = () => {
    this.props.onCloseDialog()
    this.setState({ isCancelled: true, showSnackbar:true});
  }
```

Here, you a manipulating a state object's property called `isCancelled` to a truthy value. Hence you will need to add `isCancelled` to the state object as a property with a value of `false`.  Add `handleDialogCancel` method as  a reference to an `onClick` prop of the `CANCEL` button as shown below;

```js
<DialogActions>
  <Button color="secondary" onClick={this.handleDialogCancel}>
    Cancel
  </Button>
    {/*... Other Components here*/}
</DialogActions>
```

Now what you can do is to show the dialog when it is canceled or when it is saved by updating the `Snackbar` component in `AddEvent` to this code;

```js
{this.state.isCancelled ? (
  <Snackbar
    anchorOrigin={{
      vertical: "bottom",
      horizontal: "left"
    }}
    open={this.state.showSnackbar}
    autoHideDuration={6000}>
    <MySnackbarContentWrapper/>
  </Snackbar>
  ) : (
  <Snackbar
      anchorOrigin={{
        vertical: "bottom",
        horizontal: "left"
      }}
      open={this.state.showSnackbar}
      autoHideDuration={6000}>
      <MySnackbarContentWrapper/>
  </Snackbar>
)}
```

But there is an issue, same message, and color of dialog box. Let's customize `MySnackbarContentWrapper` to have a custom message and a color of the dialog box depending on the state of the form whether it was canceled or successfully submitted. This means you have to pass props around the `MySnackbarContentWrapper` component. The main props that you will need are `variant` and `message` for the dialog color and the content respectively.
Update `MySnackbarContentWrapper` component in the `AddEvent` component to contain both the variant and message as shown below;

```js
{this.state.isCancelled ? (
  <Snackbar
    {/*... Some Props*/}
    >
    <MySnackbarContentWrapper
      variant="error"
      message="Form Got Cancelled"
    />
  </Snackbar>
  ) : (
  <Snackbar
    {/*... Some Props*/}
    >
      <MySnackbarContentWrapper
        variant="success"
        message="Data Successfully Saved"
       />
  </Snackbar>
)}
```

You have to use the `message` and `variant` in the `MySnackbarContent` component by updating the component definition too;

```js
// Some imports

// An Icon definition

// Some Styles

const MySnackbarContent = props => {
  const { classes, className, variant, message } = props;
  const Icon = variantIcon[variant];

  return (
    <SnackbarContent
      className={classNames(classes[variant], className)}
      aria-describedby="client-snackbar"
      message={
        <span id="client-snackbar" className={classes.message}>
          <Icon className={classNames(classes.icon, classes.iconVariant)} />
          {message}
        </span>
      }
      action={[
        <IconButton
          key="close"
          aria-label="Close"
          color="inherit"
          className={classes.close}
        >
          <CloseIcon className={classes.icon} />
        </IconButton>
      ]}
    />
  );
};

export default withStyles(styles)(MySnackbarContent);
```


**NB** Sometimes, the `Snackbar` component autoHideDuration does not work, so you can manually close with onClose props and then pass a  method reference that hides the snackbar. For instance, this method will hide the snackbar when passed as a reference to Snackbar's `onClose` prop.

```js
  handleCloseSnackbar = () => {
    this.setState({ showSnackbar: false });
  };
```

A lot has been done here using Material-UI to build modern UI for React application by wiring up various components. In the next sections, you will have a look at how you can secure React Applications with Auth0.  

## Securing Your React App with Auth0

You have a working React App. In this section, you will learn how to secure React application with Auth0.  For those of you who don't know much about Auth0, you can read more about it from its [official website](https://auth0.com/). In using Auth0 to secure your React App, it involves `Sign up for Auth0`, `Create Auth0 App` and `Setup Configuration Values`.

Visit the website to create an account by following the instructions page by page. Once you have finished creating your account, Auth0 dashboard page will be launched. There you create the `Auth0 app` which points to the React app.  To create an `Auth0 app` on the dashboard click on `New Application` then you choose a name for the app, say `react-material-ui` for instance and then select `Single Page Applications`(SPA's) as the type of application since React is used in creating SPAs. Finally, there is a widget that asks you the technology you are using to create your application. Since you are using React, you have to select React. Then a page is presented with tutorials on how to setup Auth0 with React Application.  Instead of copying and pasting directly, let's do something different but you can still go ahead with the tutorials.

Still, on Auth0 dashboard, click on `Applications` and then select the application you just created. There you have an overview of the Auth0 app you created. Under settings, you have default settings for SPA's which includes, `name, domain, client id, client secret, etc.` You are going to be using some of these settings in your code to configure your app to use Auth0, so you need to take notice of these. 

### Integration Auth0 Authentication in React App

Auth0 provides API's to handle authentication and authorization for your applications. Here, you will be using the Auth0 authentication in your application to handle users to log in with their credentials. To do you so you will need a package called `auth0.js` that contains functions to interact with Auth0. Install this package using the command `npm install auth0-js`

Once you have it installed, you have to configure your application to be identified by Auth0. This why you created the `Auth0 App`. This has some information that you can use in your application thus linking your App to Auth0. For this, you have to create a file that would hold your `Auth0 App` information. Preferred file for this kind of task is environment variable file. Create an environment variable file as `.env` at the root of your project. In that file, you are going to specify a few variables using certain information from the `Auth0 App` settings as demonstrated below

```bash
REACT_APP_AUTHO_DOMAIN=xxxx

REACT_APP_AUTHO_CLIENTID=xxx

REACT_APP_AUTHO_CALLBACKURL=http://localhost:3000/callback
```

Here, you are specifying the domain, client id, and callback URL. You can get the domain as well as the client id from the settings of the `Auth0 App`. Once you get them to replace `xxx` with those values respectively. Also in the same settings, fill the `Allowed Callback URLs` with `http://localhost:3000/callback`. This is the URL that the user will be redirected to after the user is authenticated. 

A very quick notice, you can see that the environment variables start with `REACT_APP`. This is how `create-react-app` expects the variables to be stored in order for it to automatically expose those variables.

With the help of Auth0 package, you can now use the `.env` information to interact with Auth0. In the `src` folder of your application create a folder called `service` which will hold a `Auth.js` file. In the `Auth.js` file, add these code;

```js
import auth0 from "auth0-js";

export default class Auth {
  constructor(history) {
    this.history = history;
    this.auth0 = new auth0.WebAuth({
      domain: process.env.REACT_APP_AUTHO_DOMAIN,
      clientID: process.env.REACT_APP_AUTHO_CLIENTID,
      redirectUri: process.env.REACT_APP_AUTHO_CALLBACKURL,
      responseType: "id_token",
      scope: "openid profile"
    });
  }

  getProfile = () => {
    return this.profile;
  };

  getIdToken = () => {
    return this.idToken;
  };

  isAuthenticated = () => {
    return new Date().getTime() < this.expiresAt;
  };

  signIn = () => {
    this.auth0.authorize();
  };

  handleAuthentication = () => {
    this.auth0.parseHash((err, authResult) => {
      if (err) {
        this.history.push("/");
      }
      if (authResult && authResult.idToken) {
        this.setSession(authResult);
        this.history.push("/");
      }
    });
  };

  signOut = () => {
    this.idToken = null;
    this.profile = null;
    this.expiresAt = null;
    this.auth0.logout({
      clientID: process.env.REACT_APP_AUTHO_CLIENTID,
      returnTo: "http://localhost:3000"
    });
  };

  setSession = authResult => {
    this.idToken = authResult.idToken;
    this.profile = authResult.idTokenPayload;
    this.expiresAt = authResult.idTokenPayload.exp * 1000;
  };
}
```
Here, you began by importing  `auth0-js` and then declared `Auth` class. This class is constructed by accepting `react-router` history hence you can perform routing functionality like redirects here. Also, during the construction of the Auth class, you are instantiating the auth0.webAuth that accepts options object with `domain` as a key and its value reference the domain environment variable and the list continues for `clientID` and `redirectUri`.  Also, the options object has `responseType` which gives the type of response after user authentication. Here the `responseType` is an `id_token` which give you a JWT token to the authenticate the user after they log in. The last but not the least option is the `scope` which specify permission. The kind of permission to be used here is `openid` and would like to obtain basic information of the user, thus the user's profile such as name, picture, etc.  

The Auth class has  `getProfile`, `getIdToken`, `isAuthenticated`, `signIn`, `handleAuthentication`, `signOut` and `setSession` methods which use class property syntax for their definitions. And their names depict their function. For instance `signIn` uses auth0 authorize method to log in the user. 0

To use this class in other components, you need to wire it up with the app so other components can use its instance. This can be done in the `App.js` and then pass it down to other components.  Open the `App.js` file and import and instantiate the `Auth` class in the constructor.

The `HomePage` component has the login button and for the user to login with Auth0, you need to pass that instance to the HomePage as props. 

```js
//... Other Imports Here
import Auth from './service/Auth'

//... Styles Here

class App extends Component {

  constructor(props){
    super(props)
    this.state ={
      data: []
    }

    this.auth = new Auth(this.props.history);
  }
  //...  Other Method
  render() {
    return (
      <div style={divStyle}>
        {/*... Other Components */}
        <Route path="/" exact component={() => <HomePage auth={this.auth}/>}/>
        {/*... Other Routes */}
      </div>
    );
  }
}
```

Now in the `HomePage` component, you can then pass the incoming prop, auth's signIn method as a reference to the onClick property on `Button` component as shown below 

```js
<Button
  {/*... Other Props */}
  onClick={this.props.auth.signIn}>  
  Login
</Button>
```

Go ahead and test the login functionality with Auth0. It works perfectly, but wait! After login, the page hangs on to an empty page with a long string value in the `Browser` address bar. That long string value is the result from authenticating the user and we have to handle that. Well, you remember while specifying the environment variables, you had a callback url. That needs to be executed after a successful login. What you can do now is to create such url but URL in react must come with a component so you need to create a component for this functionality. 

Go ahead to create a component named `Callback` in your components folder.  In that `Callback.js` file add these code;

```js
import React, { Component } from "react";
import { withRouter } from "react-router-dom";

class Callback extends Component {
  componentDidMount() {
    this.props.auth.handleAuthentication();
  }

  render() {
    return <p>Loading profile...</p>;
  }
}

export default withRouter(Callback);

```

This component accepts auth props and then executes its `handleAuthentication` method. In order for this to be executed after the user is authenticated, you have to set it up as a route. In the `App.js` file setup another route as shown below;

```js
//... Other Imports Here
import Callback from "./components/Callback";


//... Styles Here

class App extends Component {
  //...  Other Methods
  render() {
    return (
      <div style={divStyle}>
        {/*... Other Components and Routs */}
        <Route path="/callback"  component={() => <Callback auth={this.auth}/>}/>
      </div>
    );
  }
}
```

Now after the login is successful, the user is redirected to `Callback` component.

Now once you are authenticated, you can use Auth0 functionality to achieve authorization such as not allowing users to visit the dashboard page without being authenticated or even hiding the login button after login. 

  1. Preventing user from accessing the dashboard page 

This is pretty much simple, you have to call the `isAuthenticated` method which gives a boolean value. So in the `App.js` update the Dashboard Route to;

```js
 <Route
    path="/dashboard"
    component={() =>
      this.auth.isAuthenticated() 
        ? <Dashboard auth={this.auth} data={this.state.data} />
        : <Redirect to="/" />
    }
/>
```

You are just redirecting the user to the homepage if the user is not logged in. That means you have to also import the `Redirect` module from `react-router-dom`.

  2. Hiding the Login button after login

After the user is logged in the button must be hidden and that can be achieved simply by rendering null if the user is logged in else render the button. update the `Button` section of the  `homepage.js` to the code below;

```js
{this.props.auth.isAuthenticated() 
  ? null
  : <Button
      variant="contained"
      color="primary"
      onClick={this.props.auth.signIn}
    >                       
      Login
    </Button>
}
```

  3. Hiding `Add Event`, `Logout` and `My Account` labels on the MenuAppBar Component
 
The MenuAppBar houses `Add Event`, `Logout` and `My Account` labels. The `Add Event` label shows the addEvent dialog resides in the Header component.  That item should only be shown when the user is logged in else show nothing. You got to update that portion of code as well. Before that, you need to pass the auth instance to the header component through probs. Therefore you have to update the `<MenuAppBar createEvent={this.createEvent}/>` in the App.js to `<MenuAppBar createEvent={this.createEvent} auth={this.auth}/>

In the header.js file, update the ListItem that has the `Add Event` label to;

```js
{
  this.props.auth.isAuthenticated()
  ? <ListItem button onClick={this.handleClickOpenDialog}>
      <ListItemIcon>
        <Add />
      </ListItemIcon>
      <ListItemText primary="Add Event" />
    </ListItem>
  : null
}
```

The `Logout` and `My Account` labels are shown in the dropdown menu.  The entire block of code from `<IconButton>` to `</Menu>`  in the MenuAppBar component should be updated to;

```js
{
  this.props.auth.isAuthenticated()
  ?(
    <div>
      <IconButton
        onClick={this.handleMenuOpen}
        color="inherit">
        <AccountCircle />
      </IconButton>
      <Menu
        anchorOrigin={{
          vertical: "top",
          horizontal: "right"
        }}
        anchorEl={this.state.anchorEl}
        open={showPopOver}
        onClose={this.handleMenuClose}
        >
        <MenuItem>
          <NavLink
            to="/account"
            style={{ textDecoration: "none", color: "black" }}>
            My Account
          </NavLink>
        </MenuItem>
        <MenuItem>Logout</MenuItem>
    </Menu>
    </div>
  )
  : null
}
```
Thus the IconButton that hold the ` My Account ` and `Logout` labels should not be shown when user is not logged in.

You can now wire up the Logout functionality to the `Logout` MenuItem by just referencing `this.props.auth.signOut` method on the auth instance to the `onClick` props on the `MenuItem` as shown below;

```js
 <MenuItem
    onClick={this.props.auth.signOut}>
    Logout
  </MenuItem>
```

When you click on `My Account` an empty page is shown.  You have not created any component for that page yet.  Let's take a look at how you can create a component that will hold the logged in user details.

### Implementing the Account component

This Account component will be made up of a Card component from Material-UI. Card component is also made of CardHeader for displaying caption, CardMedia to display any media content. CardContent to hold the main content and CardActions will be used in case of performing any action related to the card module. In the `pages` sub-folder create a sub-folder named `Account`. In the newly created `Account` folder create `Account.js` file and add these code to it. 


```js
import React from "react";
import {withStyles} from "@material-ui/core/styles";
import classnames from "classnames";
import Card from "@material-ui/core/Card";
import CardHeader from "@material-ui/core/CardHeader";
import CardMedia from "@material-ui/core/CardMedia";
import CardContent from "@material-ui/core/CardContent";
import CardActions from "@material-ui/core/CardActions";
import Collapse from "@material-ui/core/Collapse";
import IconButton from "@material-ui/core/IconButton";
import Typography from "@material-ui/core/Typography";
import ExpandMoreIcon from "@material-ui/icons/ExpandMore";
import Grid from "@material-ui/core/Grid";

const styles = theme => ({
  root: {
    flexGrow: 1,
    marginTop: 30,
  },
  card: {
    maxWidth: 400
  },
  media: {
    height: 0,
    paddingTop: "56.25%"
  },
  actions: {
    display: "flex"
  },
  expand: {
    transform: "rotate(0deg)",
    marginLeft: "auto",
    transition: theme.transitions.create("transform", {
      duration: theme.transitions.duration.shortest
    })
  },
  expandOpen: {
    transform: "rotate(180deg)"
  }
});
class AccountDetails extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      expanded: false,
      profile: {},
      imagePlaceHolder:"./placeholder.png"
    };
  }

  componentDidMount() {
    let profile = this.props.auth.getProfile()
    this.setState({ profile, imagePlaceHolder: profile.picture })
  }

  handleExpandClick = () => {
    this.setState(state => ({ expanded: !state.expanded }));
  };

  render() {
    const { classes } = this.props;
    const { profile } = this.state;
    return (
      <div className={classes.root}>
        <Grid container alignItems="center" justify="center">
          <Card className={classes.card}>
            <CardHeader title={profile.nickname} />
            <CardMedia
              className={classes.media}
              image={this.state.imagePlaceHolder}
              title={profile.name}
            />
            <CardContent>
              <Typography variant="h5" gutterBottom={true}>
                Other Profile Data
              </Typography>
            </CardContent>
            <CardActions className={classes.actions} disableActionSpacing>
              <IconButton
                className={classnames(classes.expand, {
                  [classes.expandOpen]: this.state.expanded
                })}
                onClick={this.handleExpandClick}
                aria-expanded={this.state.expanded}
                aria-label="Show more"
              >
                <ExpandMoreIcon />
              </IconButton>
            </CardActions>
            <Collapse in={this.state.expanded} timeout="auto" unmountOnExit>
              <CardContent>
                <Typography component={"span"} variant={"body2"}>
                  <pre>{JSON.stringify(profile, null, 2)}</pre>
                </Typography>
              </CardContent>
            </Collapse>
          </Card>
        </Grid>
      </div>
    );
  }
}
export default withStyles(styles)(AccountDetails);

```

Most of the code here won't be that new to you. You are following the same style of writing code where you have imported the modules you will need to create your card, your CSS-in-JS named as `styles` which is basically providing styling to component and few methods to be rendered on this component as well.  One of the most essential takeaways would be image rendering in card component especially when you are retrieving the image from a particular web service, you will need a default image to be rendered and then later be updated with the image that would be fetched from the web service.

This account component retrieves the logged in user's profile and then outputs the details in the card as demonstrated above. 

Once you have this account setup, you will have to import it in your root component, that's the `App.js` file and create its route as shown below;

```js
// ... other imports ...
import AccountDetails from "./pages/Account/Account";

class App extends Component {
  // ... constructor
  render() {
    return (
      <div style={divStyle}>
        {/*other ... routes */}

        <Route
          path="/account"
          component={() =>
           this.auth.isAuthenticated() 
            ? <AccountDetails auth={this.auth}/>
            : <Redirect to="/" />
          }
        />
      </div>
    );
  }
}
```

You can now test your `My Account` link by clicking on it to route to `/account`. 

### Implementing silent authentication

If you have noticed, anytime you refresh the browser even though you are logged in, you are automatically logged out. Their reason is after the user is logged in, the data from the `Auth0` response is then handled by `handleAuthentication` method in the `Auth.js` file.  The data is currently stored in-memory of the class properties and that does not store the user session permanently. 

Options like localStorage have been one of the means to store such user information permanently but they have their own issues in terms of security.  Auth0 recommends an approach called [silent authentication](https://auth0.com/docs/api-auth/tutorials/silent-authentication) to check if the user still has a session or lost session. In this section, you are going to implement such a feature in this sample project. 

In your `Auth.js` class, add this method;

```js
silentAuth() {
  return new Promise((resolve, reject) => {
    this.auth0.checkSession({}, (err, authResult) => {
      if (err) return reject(err);
      this.setSession(authResult);
      resolve();
    });
  });
}
```
By default JWT from Auth0 expires after 3600 seconds which is about 10 hours hence the user must be logged in for such period.  To still make user logged in, you make HTTP call behind the scene using Auth0's `checkSession` method to check if the current user is still having a session on Auth0 server and if so then the user can still access the page else, you are logged out. 

When and where then do you call this method? This must be called anytime there is a request and since request are handled by routes, you can make use of the `silentAuth` method in `App.js` since that is where all Routes are defined.
In the `src/App.js` file update the code as follows;

```js
// ... other imports
import {Route, withRouter} from 'react-router-dom';

class App extends Component {
  // ... constructor here 
  async componentDidMount() {
    if (this.props.location.pathname === '/callback') return;
    try {
      await auth0Client.silentAuth();
      this.forceUpdate();
    } catch (err) {
      if (err.error !== 'login_required') console.log(err.error);
    }
  }

  // ... render
}

export default withRouter(App);
```

Here, you defined what to do when your app loads (componentDidMount):
*  If the incoming route is `/callback`, the app does nothing. And that is expected behavior because, `/callback` route, is called after the authentication process. In this case, you can leave the Callback component to handle the process.

* If the requested route is anything else, the app wants to try a silentAuth. Then, if no error occurs, the app calls forceUpdate so the user can see whatever they asked for.

* If there is an error on the silentAuth, the app checks if the error is different than login_required. If this is the case, the app logs the problem. Otherwise, the app does nothing because it means the user is not signed in 


Also, you are enclosing your App class inside the withRouter function so you can check what route is being called using `this.props.location.pathname`. Without withRouter, you wouldn't have access to the location object.


With all these changes made and to make this method work as expected, you have to do few changes to your `Auth0 App` settings. In your `Auth0 App` settings, add these changes;
  1.  Allowed Web Origins: As your app is going to issue an AJAX request to Auth0, you will need to add http://localhost:3000 to this field. Without this value there, Auth0 would deny any AJAX request coming from your app.

  2. Allowed Logout URLs: To enable users to end their session at Auth0, you will have to call the [logout endpoint](https://auth0.com/docs/logout#log-out-a-user). Similarly to the authorization endpoint, the log out endpoint only redirects users to whitelisted URLs after the process. As such, you will have to add http://localhost:3000 in this field too.


After updating these fields, you can hit the `Save Changes` button. Then, the last thing you will have to do before focusing in your app's code is to replace the development keys that Auth0 is using to enable users to authenticate through Google.


You might not have noticed but, even though you didn't configure anything related to Google in your Auth0 account, the social login button is there and works just fine. The only reason this feature works out of the box is that Auth0 auto-configure all new accounts to use development keys registered at Google. However, when developers start using Auth0 more seriously, they are expected to replace these keys with their own. And, to force this, every time an app tries to perform a silent authentication, and that app is still using the development keys, Auth0 returns that there is no session active (even though this is not true).

So, to change these keys, move to [the Social Connections on your dashboard](https://manage.auth0.com/#/connections/social), and click on Google. There, you will see two fields among other things: Client ID and Client Secret. This is where you will insert your keys. To get your keys, please, read [the Connect your app to Google documentation provided by Auth0](https://auth0.com/docs/connections/social/google).

**Note:** If you don't want to use your Google keys, you can deactivate this social connection and rely only on users that sign up to your app through Auth0's Username and Password Authentication.



## Conclusion

Congratulations, you have come a long way to get started with the basics of using Material-UI in React applications. You will bear with me that not all the components that come with Material-UI were covered but you can use the same pattern of importing components, defining styles for components and using components as well as working with their props and finally enclosing your component class inside the `withStyles` for the style to have effect on various components that used them to build any React application using Material-UI. 

Also, you lately wired up the application to use Auth0 for authentication and authorization. Continue to explore more of how Auth0 can help you build well-secured applications.

Also, if you need help, do not hesitate to leave a message on the comments section down below. Have fun with it, thanks. 




